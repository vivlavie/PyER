#! /usr/bin/env python
import itertools
import kfx
import kfxtools
import sys
import re
import os
import commands
import random
import numpy as np
import csv
import shutil
import shelve
import scipy.interpolate as intp
import matplotlib.pyplot as plt
import matplotlib.cm as cmx
import matplotlib.colors as colors
#import pandas as pd
def create_condor(stig, num_scen):
#	text='#!/bin/sh\n# Kam run script generated by kfx2condor\n# **************************************\nsource /nfs/misc/kfx/KFX2010_v1.6/bin/kfxinit.sh\n'
#	text=text+"#source /opt/KFX2010_v1.4/Linux_x86_64/bin/kfx2010v14\n#PATH=\"$PATH:/opt/KFX2007_SP1.3/bin\";export PATH\n#KAM_MODE=Default;export KAM_MODE\nUNAME=Linux_x86_64;export UNAME\n"
#	text=text+"cd "+stig+"$1\n"
#	text=text+"/nfs/misc/kfx/KFX2010_v1.6/bin/runkam scenario.fsc -mu > scenario.status.log"
#	kam=open(stig+'Kam.sh','w')
#	kam.write(text)
#	kam.close()
#	text="# Condor file generated by Spangelo\n# ***********************************\n\n"
#	text=text+"universe = vanilla\nexecutable = "+stig+"Kam.sh\n"
#	text=text+"output = a5_$(process).out\nerror = a5_$(process).err\nlog = a5_$(process).log\n"
#	for i in range(num_scen):
#		text=text+"arguments = Scenario_"+str(i+1)+"/\nqueue\n"
#	kam=open(stig+'cb.cmd','w')
#	kam.write(text)
#	kam.close()	
#	os.chmod(stig+'Kam.sh', 0777)
        text='#!/bin/sh\n# Kam run script generated by kfx2condor\n# **************************************\nsource /nfs/misc/kfx/kfx_v2.2-4/bin/kfxinit.sh\n'
        text=text+"UNAME=Linux_x86_64;export UNAME\n"
        text=text+"cd /nfs"+stig+"$1\n" #obf: added /nfs
        text=text+"/nfs/misc/kfx/kfx_v2.2-4/Linux_x86_64/bin/runkam scenario.fsc > scenario.status.log"
        kam=open(stig+'Kam.sh','w')
        kam.write(text)
        kam.close()
        text="# Condor file generated by Spangelo\n# ***********************************\n\n"
        text=text+"universe = vanilla\nexecutable = /nfs"+stig+"Kam.sh\n" #obf: added /nfs
        text=text+"output = a5_$(process).out\nerror = a5_$(process).err\nlog = a5_$(process).log\n"
        for i in range(num_scen):
                text=text+"arguments = Scenario_"+str(i+1)+"/\nqueue\n"
        kam=open(stig+'cb.cmd','w')
        kam.write(text)
        kam.close()
        os.chmod(stig+'Kam.sh', 0777)
def createxml(string):
#	os.system('rsync -avz /nfs/home/mlu/SETUP_FIRE/scenario.xml '+string)
	text='<?xml version = "1.0" encoding="UTF-8" standalone="no" ?>\n<kfxScript>\n   <atFixedTimeInterval dt="10">\n' #obf: Changed from dt=3 to dt=10
	text+='      <save type="field" macro="SIGHT">\n         <file name="$c_sight_$t.r3d" counter="4" />\n      </save>\n   </atFixedTimeInterval>\n   <atAllTimeSteps>\n'
	text+='   </atAllTimeSteps>\n   <atExit>\n      <save type="field" macro="s">\n         <file name="$c_std_exit.r3d" counter="12" />\n      </save>\n'
	text+='      <save type="field" macro="SIGHT">\n         <file name="$c_sight_exit.r3d" counter="12" />\n      </save>\n      <save type="field" macro="RA35">\n'
	text+='         <file name="$c_RA35_exit.r3d" counter="12" />\n      </save>\n   </atExit>\n</kfxScript>'
	fil=open(os.path.join(string,'scenario.xml'),'w')
	fil.write(text)
	fil.close()
def createfsc(w,string,d,B,TPOOL,graph):
	A=False
	C=True
	CELL_TYPE=False
	pwd=os.getcwd()
	poro_out=os.path.join(os.path.join(pwd,'PORO'),string[:-1]+'_poro.r3d')	
	string=os.path.join(pwd,string)
	createxml(string)
	shutil.copy(os.path.join(string,'scenario_poro.r3d'),poro_out)
	pwd=os.path.join(pwd,str(w)+'ms')+'/'
	make_dir(pwd)
	w_ang=0.0
	V='NORTH','SOUTH','EAST','WEST'
#	V='NORTH','SOUTH'
	if os.path.isfile(os.path.abspath(graph)+'/scen_input'):
		fil=open(os.path.abspath(graph)+'/scen_input','r')
		for f in fil:
			print f.split()
			if len(f.split())==2:
				if str(f.split()[0])=='Max_time':
					max_time=str(f.split()[1])
				elif str(f.split()[0])=='COUMAX':
					coumax=str(f.split()[1])
				elif str(f.split()[0])=='Sea_level':
					sea_level=str(f.split()[1])
				elif str(f.split()[0])=='Amb_temp':
					amb_temp=str(f.split()[1])
				elif str(f.split()[0])=='Angle_wind':
					w_ang=float(f.split()[1])*np.pi/180
		fil.close()
	else:
		print os.path.abspath(graph)+'/scen_input dose not exist.'
	mmm=0
	Change=False
	controlfil=open(string+"scenario.control",'r')
	text=''
	for l in controlfil:
		if len(l.split('='))==2:
			if str(l.split('=')[0])=='Time_end':
				text=text+'Time_end='+max_time+'\n'
			elif str(l.split('=')[0])=='Max_step':
				text=text+'Max_step=200000\n'
			elif str(l.split('=')[0])=='coumax':
				text=text+'coumax='+coumax+'\n'
			elif str(l.split('=')[0])=='dtmin':
				text=text+'dtmin=0.0005\n'
			else:
				text=text+str(l)
		else:
			text=text+str(l)
	controlfil.close() 
	controlfil=open(string+"scenario.control",'w')	
	controlfil.write(text)	
	controlfil.close()
	if TPOOL:
		num_dir=1
		C=False	
	else:
		num_dir=6
	for j in V:
		make_dir(pwd+str(j)+'/')
		for i in range(num_dir):
			inn=pwd+str(j)+"/Scenario_"+str(d*num_dir+i+1)+'/'
			make_dir(inn)
			os.system('rsync -avz --exclude scenario_poro.r3d '+string+'* '+inn )
			os.symlink(poro_out,inn+'scenario_poro.r3d')
			fscfil=open(inn+"scenario.fsc",'r')
			text=''
			if j=="NORTH":
				u10='-%2.2f'%(float(w)*np.sin(w_ang))
				v10='-%2.2f'%(float(w)*np.cos(w_ang))
			if j=="SOUTH":
				u10='%2.2f'%(float(w)*np.sin(w_ang))
				v10='%2.2f'%(float(w)*np.cos(w_ang))
			if j=="EAST":
				u10='-%2.2f'%(float(w)*np.cos(w_ang))
				v10='%2.2f'%(float(w)*np.sin(w_ang))
			if j=="WEST":
				u10='%2.2f'%(float(w)*np.cos(w_ang))
				v10='-%2.2f'%(float(w)*np.sin(w_ang))
			for l in fscfil:
				if Change:
					mmm+=1
				if len(l.split())==3:
					if str(l.split()[1])=='VPH' and str(l.split()[2])=='0.3-0.7':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='VPH' and str(l.split()[2])=='>0.9':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='VPH' and str(l.split()[2])=='0.7-0.9':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Y/Z' and str(l.split()[2])=='corner':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='XYZ' and str(l.split()[2])=='Corner':
						Change=True
						text=text+str(l)
					elif str(l.split()[0])=='U10':
						text=text+"U10      = "+u10+"\n"
					elif str(l.split()[0])=='V10':
						text=text+"V10      = "+v10+"\n"
					elif str(l.split()[0])=='MSTEP':
						text=text+"MSTEP    = 200000\n"
					elif str(l.split()[0])=='TMAX':
						text=text+"TMAX     = "+max_time+"\n"
					elif str(l.split()[0])=='TFIL': #added by obf (to avoid saving all the restart files)
						text=text+"TFIL     = 70\n" #added by obf
					elif str(l.split()[0])=='COUMAX':
						text=text+"COUMAX   = "+coumax+"\n"
					elif str(l.split()[0])=='DTMIN':
						text=text+"DTMIN    = 0.0005\n"
					elif str(l.split()[0])=='Z_WBREF':
						text=text+"Z_WBREF  = "+sea_level+"\n"
					elif str(l.split()[0])=='E_SCD':
						text=text+"E_SCD    = 2E+05\n"
					elif str(l.split()[0])=='E_ESCD':
						text=text+"E_ESCD   = 2E+05\n"
					elif str(l.split()[0])=='TGROUND':
						text=text+"TGROUND  = "+amb_temp+"\n"
					elif str(l.split()[0])=='T_SUR':
						text=text+"T_SUR    = "+amb_temp+"\n"
					else:
						text=text+str(l)
				elif len(l.split())==4:
					if str(l.split()[1])=='Solid' and str(l.split()[2])=='construction' and str(l.split()[3])=='cell':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Thin' and str(l.split()[2])=='horizontal' and str(l.split()[3])=='divider':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Thin' and str(l.split()[2])=='X/Y' and str(l.split()[3])=='corner':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Thin' and str(l.split()[2])=='X/Z' and str(l.split()[3])=='corner':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Steel' and str(l.split()[2])=='block/' and str(l.split()[3])=='plate':
						Change=True
						text=text+str(l)
					else:
						text=text+str(l)
				elif len(l.split())==5:
					if str(l.split()[1])=='Louvered' and str(l.split()[2])=='wall' and str(l.split()[3])=='facing' and str(l.split()[4])=='X-dir.':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Louvered' and str(l.split()[2])=='wall' and str(l.split()[3])=='facing' and str(l.split()[4])=='Y-dir.':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='VPH' and str(l.split()[2])=='0.2' and str(l.split()[3])=='-' and str(l.split()[4])=='0.3':
						Change=True
						text=text+str(l)
					else:
						text=text+str(l)
				elif len(l.split())==6:
					if str(l.split()[1])=='Thin' and str(l.split()[2])=='wall' and str(l.split()[3])=='normal' and str(l.split()[4])=='to' and str(l.split()[5])=='X-dir.'  :
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Thin' and str(l.split()[2])=='wall' and str(l.split()[3])=='normal' and str(l.split()[4])=='to' and str(l.split()[5])=='Y-dir'  :
						Change=True
						text=text+str(l)
					else:
						text=text+str(l)
				elif len(l.split())==2:
					if str(l.split()[1])=='Insulation':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Grating':
						Change=True
						text=text+str(l)
					elif str(l.split()[1])=='Jet_cell':
						A=True 
						C=False	
						text=text+str(l)
					elif CELL_TYPE and not SUBSEA:
						if l.split()[0] in lcells:
							text+='     7      1\n'
						elif l.split()[0] in frecells:
							text+='     30      1\n'
						else: 
							text=text+str(l)
					else:
						text=text+str(l)
				elif len(l.split())==11 and A:
					A=False
					speed=str(l.split()[2])
					if i==0:
						jet='0 '+speed+' 0 '			
					elif i==1:
						jet='0 -'+speed+' 0 '
					elif i==2:
						jet=speed+' 0 0 '
					elif i==3:
						jet='-'+speed+' 0 0 '
					elif i==4:
						jet='0 0 '+speed+' '
					elif i==5:
						jet='0 0 -'+speed+' '	
					line='25 '+jet+str(l.split()[4])+' '+str(l.split()[5])+' '+str(l.split()[6])+' '+str(l.split()[7])+' '+str(l.split()[8])+' '+str(l.split()[9])+' '+str(l.split()[10])
					text=text+line+'\n'
				elif len(l.split())==11 and Change:
					line=str(l.split()[0])+' '+str(l.split()[1])+' '+str(l.split()[2])+' '+str(l.split()[3])+' '+str(l.split()[4])+' '+str(l.split()[5])+' '+str(l.split()[6])+' '+amb_temp+' 0 9999 0.001 '
                                        text=text+line+'\n'
				elif len(l.split())==10 and Change and mmm==4:
					Change=False
					mmm=0
					line='2 '+str(l.split()[1])+' '+str(l.split()[2])+' '+str(l.split()[3])+' '+str(l.split()[4])+' '+str(l.split()[5])+' '+str(l.split()[6])+' '+str(l.split()[7])+' '+str(l.split()[8])+' '+str(l.split()[9])
                                        text=text+line+' \n'
				elif l.rstrip()=='@POINTER':
					text=text+str(l)
					CELL_TYPE=True
					if i<=1:
						lcells=['3','4','8']
						frecells=['5','6','23']
					elif i<=3:
						lcells=['3','5','6']
						frecells=['4','8','23']
					elif i<=5:
						lcells=['4','5','23']
						frecells=['3','6','8']
				elif l.rstrip()=='@END POINTER':
					text=text+str(l)
					CELL_TYPE=False
				else:
					text=text+str(l)	
			fscfil.close() 
			fscfil=open(inn+"scenario.fsc",'w')	
			fscfil.write(text)	
			fscfil.close()
	os.system('rm -f '+string+'scenario_poro.r3d ')	
	os.system('cp '+poro_out+' '+string+'scenario_poro.r3d ')
	B.append(C)
	return B	
def bashline(OPT,TPOOL,graph):
	make_dir('PORO/')
	pwd=commands.getoutput('pwd')
	B=[]
	D=[]
	W=[]
	V='NORTH','SOUTH','EAST','WEST'
	for el in OPT:
		if el[-1]=="/":
			D.append(el)
		else:
			W.append(el)
	for d in D:
		string=pwd+"/"+str(d)+"/"
		createxml(string)
	if TPOOL:
		num_dir=1	
	else:
		num_dir=6	
	num_scen=len(D)*num_dir
	for w in W:
		for d in range(len(D)):
			string=D[d]
			B=createfsc(w,string,d,B,TPOOL,graph)
		for v in V:
			stig=pwd+"/"+str(w)+"ms/"+str(v)+"/"
			create_condor(stig, num_scen)	
	for l in range(len(D)):
		if B[l]:
			print "\033[1;31mRemark!!!! Jet_cell dose not exist for source: "+str(D[l])+ ".\033[0;0m" 
def findk(fr,to,A):
	k=0
	x=0
	y=0
	dx=abs(A[fr][1]-A[to][1])
	dy=abs(A[fr][2]-A[to][2])
	dz=abs(A[fr][3]-A[to][3])
	if (dx!=0 and dy==0 and dz==0):
		x=str(A[fr][2])
		y=str(A[fr][3])
		k=1
	elif (dy!=0 and dx==0 and dz==0):
		x=str(A[fr][3])
		y=str(A[fr][1])
		k=2
	elif (dz!=0 and dy==0 and dx==0):
		x=str(A[fr][1])
		y=str(A[fr][2])
		k=3
	return (k,x,y)
def cgrid(fr,to,k,A,X,Y,Z):
	jj=0
	B=[]
	if float(A[fr][k])>float(A[to][k]):
		k2=fr
		k1=to
	else:
		k1=fr
		k2=to
	if k==1:
		B=X
	elif k==2:
		B=Y
	elif k==3:
		B=Z
	dist=float(A[k1][k])/1000
	while (float(A[k2][k])/1000)>dist:
		dist=(float(A[k1][k])/1000)+0.5*jj
		jj+=1
		if dist not in B:
			B.append(dist)		
	B.sort()
def sortA(b,A):	
	C=[]
	B=[]
#	b=[0,1,2, 3  , 4  , 5 , 6, 7]
#	b=[k,x,y,vmin,vmax,'o',A[fr][0],A[to][0]]
	length=len(b)-6
	B.append(b[0])
	for i in range(length):
		k1=array(str(b[6+i]),A)
		if b[0]==1:
			c=[A[k1][1],k1]
		elif b[0]==2:
			c=[A[k1][2],k1]
		if b[0]==3:
			c=[A[k1][3],k1]
#		b.pop(6+i)
		if c not in C:
			C.append(c)	
	C.sort()
	for c in C:
		B.append(c[1])
	return B	
def buildescape(OPT,A):
	B=[]
	C=[]
	D=[]
	S=[]
	fil=open(str(OPT[1]),'r')
	data=fil.readlines()
	for l in data:
		STOP=False	
		if len(l.split(','))==2 or len(l.split(','))==3:
			fr=array(str(int(l.split(',')[0])),A)
			to=array(str(int(l.split(',')[1])),A)
#			A.append([name,x,y,z,False,j])
			if fr+1>len(A):
				print ('Node '+str(l.split(',')[0])+' does not exist')
			elif to+1>len(A):
				print ('Node '+str(l.split(',')[1])+' does not exist')
			else:	
				A[fr][4]=True
				k,x,y=findk(fr,to,A)
				if k==0:
					#print A[fr]
					#print A[to]
					STOP=True
					c=[A[fr][0],A[to][0]]
					if len(l.split(','))==3:
						e=str(l.split(',')[2])
						if e.rstrip()=='e':
							D.append(c)
						else:
							C.append(c)
					else:
						C.append(c)
				if not STOP:
					if len(l.split(','))==3:
						c=[A[fr][0],A[to][0]]
						STOP=True
						e=str(l.split(',')[2])
						if e.rstrip()=='e':
							D.append(c)
						elif e.rstrip()=='s':
							S.append(c)
						else:
							print "Escape route can only be safe 's' or conected to the end point 'e'"
							print l
					if float(A[fr][k])>float(A[to][k]):
						vmax=float(A[fr][k])
						vmin=float(A[to][k])
					else:
						vmin=float(A[fr][k])
						vmax=float(A[to][k])
				for b in B:
					if STOP:
						break
					if b[0]==k and b[1]==x and b[2]==y:
						if b[3]==vmin and vmax==b[4]:
							c=[A[fr][0],A[to][0]]
							C.append(c)
							STOP=True
						elif (b[3]<=vmin and vmax<=b[4]):
							b.append(A[fr][0])
							b.append(A[to][0])
							STOP=True
						elif (b[3]>=vmin and vmax>=b[4]):
							b[3]=vmin
							b[4]=vmax
							b.append(A[fr][0])
							b.append(A[to][0])
							STOP=True
						elif (b[3]<=vmin and vmin<=b[4]):
							b[4]=vmax
							b.append(A[fr][0])
							b.append(A[to][0])
							STOP=True
						elif (b[3]<=vmax and vmax<=b[4]):
							b[3]=vmin
							b.append(A[fr][0])
							b.append(A[to][0])
							STOP=True
				if not STOP:
					if len(l.split(','))==2:
#						b=[0,1,2, 3  , 4  , 5 , 6, 7]
						b=[k,x,y,vmin,vmax,'o',A[fr][0],A[to][0]]
					else:
						s=str(l.split(',')[2])
						b=[k,x,y,vmin,vmax,s.rstrip(),A[fr][0],A[to][0]]
					B.append(b)
#	A.append([name,x,y,z,False,j])
	for a in A:
		if not a[4]:
			for b in B:
				if b[0]==1:
					x=a[1]
					y=a[2]
					z=a[3]
				elif b[0]==2:
					x=a[2]
					y=a[3]
					z=a[1]
				elif b[0]==3:
					x=a[3]
					y=a[1]
					z=a[2]
				if y==float(b[1]) and z==float(b[2]) and float(b[3])<x and x<float(b[4]):
					b.append(a[0])
					a[4]=True
	return (B,C,D,S)
def opencsn(OPT,RES):
	line=''
	t1=''
	t2=''
	t3=''
	g_escape=''
	endnode=''
	endnode1=''
	endnode2=''
	B=[]
	A=[]
	C=[]
	X=[]
	Y=[]
	Z=[]
	o=OPT[0]
	filut=str(o.split('.')[0])+'.kfx'
	i=0
	j=0
	csn=open(o,'r')
	for l in csn:
		if str(l.split(',')[0])<>'x':
			C.append(str(l.split(',')[0]))
	csn.close()
	csn=open(o,'r')
	WT=True
	for l in csn:
		if len(OPT)==3:
			if str(OPT[2])+'\n'==str(l):
				WT=False
		if len(l.split(','))==4 and WT:
			if str(l.split(',')[0])=='x':
				TR=True
				while TR:
					c=str(random.randrange(1000))
					if c not in C:
						C.append(c)
						TR=False
						name=str(c)
			else:
				name=str(l.split(',')[0])
			x=float(l.split(',')[1])*1000
			y=float(l.split(',')[2])*1000
			z=float(l.split(',')[3])*1000
			if RES:
				A.append([name,x,y,z,False,j])
				name=str(j)
				line+='COLOR: 1 0 0\nPART: rbg 1 0 0\nBOX: %4.4f'%x+' %4.4f'%y+' %4.4f'%(z+300)+' 300.0000 300.0000 -300.000\n'+'COLOR: 0 0 1\nPART: rbg 0 0 1\nTEXT: %4.4f'%(x/1000)+' %4.4f'%(y/1000)+' %4.4f'%((z+300)/1000)+' '+name+'\n'
				t1=t1+name+','+str(l.split(',')[1])+','+str(l.split(',')[2])+','+str(l.split(',')[3])
				j+=1
			else:
				A.append([name,x,y,z,False])
				line+='COLOR: 1 0 0\nPART: rbg 1 0 0\nBOX: %4.4f'%x+' %4.4f'%y+' %4.4f'%(z+300)+' 300.0000 300.0000 -300.000\n'+'COLOR: 0 0 1\nPART: rbg 0 0 1\nTEXT: %4.4f'%(x/1000)+' %4.4f'%(y/1000)+' %4.4f'%((z+300)/1000)+' '+name+'\n'
				t1=t1+name+','+str(l.split(',')[1])+','+str(l.split(',')[2])+','+str(l.split(',')[3])
		else:
			t1=t1+str(l)
	csn.close()
#	print len(OPT)	
	B,C,D,S=buildescape(OPT,A)
	for c in C:
		k1=array(str(c[0]),A)
		k2=array(str(c[1]),A)
		line+='COLOR: 1 0.8 0\nPART: rbg 1 0 0\nSBOX: %4.4f'%(A[k1][1]+150)+' %4.4f'%(A[k1][2]+150)+' %4.4f'%(A[k1][3]+150)+' %4.4f'%(A[k2][1]+150)+' %4.4f'%(A[k2][2]+150)+' %4.4f'%(A[k2][3]+150)+' 100.0000 100.000\n'
	for s in S:
		k1=array(str(s[0]),A)
		k2=array(str(s[1]),A)
		if RES:
			t3+=str(A[k1][5])+','+str(A[k2][5])+'\n'
			t2+=str(A[k1][5])+','+str(A[k2][5])+'\n'
		else:
			t3+=str(A[k1][0])+','+str(A[k2][0])+'\n'
			t2+=str(A[k1][0])+','+str(A[k2][0])+'\n'
		line+='COLOR: 0.3 0.4 1\nPART: rbg 1 0 0\nSBOX: %4.4f'%(A[k1][1]+150)+' %4.4f'%(A[k1][2]+150)+' %4.4f'%(A[k1][3]+150)+' %4.4f'%(A[k2][1]+150)+' %4.4f'%(A[k2][2]+150)+' %4.4f'%(A[k2][3]+150)+' 100.0000 100.000\n'	
		k,x,y=findk(k1,k2,A)
		cgrid(k1,k2,k,A,X,Y,Z)
	for d in D:
		k1=array(str(d[0]),A)
		k2=array(str(d[1]),A)
		if RES:
			t3+=str(A[k1][5])+','+str(A[k2][5])+'\n'
			t2+=str(A[k1][5])+','+str(A[k2][5])+'\n'
			if endnode1=='':	
				endnode1= str(A[k1][5])
				endnode2= str(A[k2][5])
			elif endnode=='':	
				if endnode1==str(A[k1][5]):
					endnode= str(A[k1][5])
				elif endnode1==str(A[k2][5]):
					endnode= str(A[k2][5])
				elif endnode2==str(A[k1][5]):
					endnode= str(A[k1][5])
				elif endnode2==str(A[k2][5]):
					endnode= str(A[k2][5])
				elif endnode!=str(A[k1][5]) and endnode!=str(A[k2][5]):
					print str(A[k1][0])+' or '+ str(A[k2][0])+' is not the end node. Only one end node is allowed.'
		else:
			t3+=str(A[k1][0])+','+str(A[k2][0])+'\n'
			t2+=str(A[k1][0])+','+str(A[k2][0])+'\n'
		line+='COLOR: 0.3 0.4 1\nPART: rbg 1 0 0\nSBOX: %4.4f'%(A[k1][1]+150)+' %4.4f'%(A[k1][2]+150)+' %4.4f'%(A[k1][3]+150)+' %4.4f'%(A[k2][1]+150)+' %4.4f'%(A[k2][2]+150)+' %4.4f'%(A[k2][3]+150)+' 100.0000 100.000\n'	
#		k,x,y=findk(k1,k2,A)
#		cgrid(k1,k2,k,A,X,Y,Z)
	for b in B:
		E=sortA(b,A)
		for k1 in range(len(E)-2):
			if RES:
				t2+=str(A[E[k1+1]][5])+','+str(A[E[k1+2]][5])+'\n'
				if 1==E[0]:
					g_escape+='PART: Escape_'+str(A[E[k1+1]][5])+'_'+str(A[E[k1+2]][5])+'\nBOX: %4.4f'%(A[E[k1+1]][1])+' %4.4f'%(A[E[k1+1]][2])+' %4.4f'%(A[E[k1+1]][3])+' %4.4f'%(float(A[E[k1+2]][1])-float(A[E[k1+1]][1]))+' %4.4f'%(1000.0000)+' %4.4f'%(2000.0000)+'\n'
				elif 2==E[0]:
					g_escape+='PART: Escape_'+str(A[E[k1+1]][5])+'_'+str(A[E[k1+2]][5])+'\nBOX: %4.4f'%(A[E[k1+1]][1])+' %4.4f'%(A[E[k1+1]][2])+' %4.4f'%(A[E[k1+1]][3])+' %4.4f'%(1000.0000)+' %4.4f'%(float(A[E[k1+2]][2])-float(A[E[k1+1]][2]))+' %4.4f'%(2000.0000)+'\n'
				elif 3==E[0]:
					g_escape+='PART: Escape_'+str(A[E[k1+1]][5])+'_'+str(A[E[k1+2]][5])+'\nBOX: %4.4f'%(A[E[k1+1]][1])+' %4.4f'%(A[E[k1+1]][2])+' %4.4f'%(A[E[k1+1]][3])+' %4.4f'%(1000.0000)+' %4.4f'%(1000.0000)+' %4.4f'%(float(A[E[k1+2]][3])-float(A[E[k1+1]][3]))+'\n'
			else:
				t2+=str(A[E[k1+1]][0])+','+str(A[E[k1+2]][0])+'\n'
			line+='COLOR: 1 0 0\nPART: rbg 1 0 0\nSBOX: %4.4f'%(A[E[k1+1]][1]+150)+' %4.4f'%(A[E[k1+1]][2]+150)+' %4.4f'%(A[E[k1+1]][3]+150)+' %4.4f'%(A[E[k1+2]][1]+150)+' %4.4f'%(A[E[k1+2]][2]+150)+' %4.4f'%(A[E[k1+2]][3]+150)+' 100.0000 100.000\n'	
			cgrid(E[k1+1],E[k1+2],E[0],A,X,Y,Z)	
	line+='COLOR: 0.7 0.7 0.7\nPART: rbg 0.7 0.7 0.7\n'
	if RES:
		fil=open('escape.kfx','w')
		fil.write(g_escape)
		fil.close()
		csvfil('nodecords.csv',t1)
		csvfil('connectivity.csv',t2)
		csvfil('safe_connections.csv',t3)
		t3=''
		for x in X:
			t3+=str(x)+' '
		t3+='\n'
		for y in Y:
			t3+=str(y)+' '
		t3+='\n'
		for z in Z:
			t3+=str(z)+' '
		t3+='\n'
		fil=open('newGrid.dat','w')
		fil.write(t3)
		fil.close()
		fil=open('endnode','w')
		fil.write(endnode)
		fil.close()
	else:
		fil=open(str(OPT[0]),'w')
		fil.write(t1)
		fil.close()
	#	csvfil(str(OPT[1]),t2)
	fil=open(filut,'w')
	fil.write(line)
	fil.close()
def kfxgeo(OPT,RES):
	opencsn(OPT,RES)
###################################### Volume calc res #######################################################
def dimcalc(k,l,vmin,vmax):
	xmin=l[k+1]+(l[k+2]-l[k+1])/2.0
	xmax=l[k+2]+(l[k+3]-l[k+2])/2.0
	if xmin<vmin:
		xmin=vmin
	if vmax<xmax:
		xmax=vmax
	dx=round(xmax-xmin,3)
	return dx
def findpos(v, pktmin,pktmax):
        ith=-2
	first=True
        for upnum in v:
		if pktmin<=upnum and first:
			first=False
			mini=ith
			maxi=ith
                elif pktmin<upnum and upnum<=pktmax:
             		maxi=ith         
		ith+=1
        return (mini,maxi)
def getgrid(fname):
	fil=open(fname,'r')
	A=fil.readlines()
	fil.close()
	F=False
	G2=False
	G1=True
	B=[]
	t1=t2=''
	for a in A:
		if str(a.rstrip())=='@END CARTESIAN GRID' or str(a.rstrip())=='@END CARTESIAN_GRID':
			F=False
			break
	#		B=B.astype(float)
		if F:
			a=a.rstrip()
			if len(B)==0:
				B=a.split(' ')
				#B=np.array(B,dtype=float)
				B=np.array(B)
			else:
				B=np.append(B,a.split(' '))
		if a.rstrip()=='@CARTESIAN_GRID':
			F=True
	a=[]
	for b in B:
		if isnumeric(b):
			a.append(b)
	a=np.array(a,dtype=float)
	return a	
def coord_split(A):
	new=-100000
	j=0
	X=[]
	Y=[]
	Z=[]
	for a in A:
		old=new
		new=a
		if old==new:
			j+=1
		if j==1 or j==2:
			X.append(old)
		if j==3 or j==4:
			Y.append(old)
		if j==5 or j==6:
			Z.append(old)
	Z.append(old)
	X=np.array(X)[1:-1]
	Y=np.array(Y)[1:-1]
	Z=np.array(Z)[1:-1]
	return X,Y,Z
def index(A,a0,a1):
##	print A,a0,a1
	n1=np.where(A<=a0)[0][-1]
	n2=np.where(A>=a1)[0][0]
#	print A[np.where(A>=a1)[0]]
	dA=A[np.where(A>=A[n1])]
	dA=dA[np.where(dA<=A[n2])]
	dA[0]=a0
	dA[-1]=a1
#	print dA,n1,n2
	return dA,n1,n2
def get_volumes(v,dx,dy,dz,P,bc,sign):
	c=v[dx[1]:dx[2],dy[1]:dy[2],dz[1]:dz[2]]
	p=P[dx[1]:dx[2],dy[1]:dy[2],dz[1]:dz[2]]
	vol_tot=0
	print 'number of cells: ',p.shape[0]*p.shape[1]*p.shape[2]
	dvol=0
	conc_max=c.max()
	conc_min=c.min()
	for k in range(c.shape[2]):
		lz=(dz[0][k+1]-dz[0][k])
		for j in range(c.shape[1]):
			ly=(dy[0][j+1]-dy[0][j])
			for i in range(c.shape[0]):
				lx=(dx[0][i+1]-dx[0][i])
				cell_vol=lx*ly*lz
				conc=c[i,j,k]*sign
				poro=p[i,j,k]
				vol_tot+=cell_vol*poro
				if conc>=bc:
					dvol+=cell_vol*poro
	return vol_tot,dvol,conc_min,conc_max
def volum_s(u1,scenario,d,C,vari,bc,f,sign):
	B=getgrid(os.path.join(d,'scenario.fsc'))
	X,Y,Z=coord_split(B)
	b=[scenario]
	Cmax=[scenario]
	Cmin=[scenario]
	std = kfxtools.readr3d(os.path.join(d,'scenario_std_exit.r3d'))
	r3d = kfxtools.readr3d(os.path.join(d,'scenario_'+vari+'_exit.r3d'))
	P=std.fields[-2]
	v=r3d.fields[0]
	v=v[1:-1,1:-1,1:-1]
	P=P[1:-1,1:-1,1:-1]
	for c in C:
		print 'volume:',c
		dx=index(X,c[0],c[3])
		dy=index(Y,c[1],c[4])
		dz=index(Z,c[2],c[5])
#		print dy[0],r3d.y[dy[1]],r3d.y[dy[2]],c[1],c[4]
		vol_tot,vol,conc_min,conc_max=get_volumes(v,dx,dy,dz,P,bc,sign)
		#print vol,vol_tot,vol/vol_tot
		if vol_tot==0:
			vol_tot=1
		if str(u1)=='spe': 
			if (vol/vol_tot)>=float(f):
				b.append('Inf')
			else:
				b.append('1')
		elif str(u1)=='pll':
			b.append(vol/(vol_tot))
		elif str(u1)=='vol':
			b.append(vol)
		else:
			b.append(0)
		Cmin.append(conc_min)
		Cmax.append(conc_max)
	return b,Cmin,Cmax
def pacalc(a,l,PARA,graph,string,vari):
	G=[]
	B=[]
	C=[]
	W=[]
	Cmin=[]
	Cmax=[]
	if str(a[-1])=='/':	
		aa=a
	else:	
		aa=a+'/'
	if str(l[-1])=='/':	
		ll=l
	else:	
		ll=l+'/'
	if str(graph[-1])!='/':	
		graph=graph+'/'
	dird=os.getcwd()+'/'+aa+ll
	dirg=os.getcwd()+'/'+graph
	G.append(os.getcwd()+'/'+aa+ll+'EXPLOR_R3D/')
	for g in G:
		make_dir(g)
	r3dname='scenario_'+vari+'_exit.r3d'	
	find(r3dname,'scenario_std_exit.r3d',dird,str(G[0]))
	b=[]
	if str(PARA[0])=='vol':
		if len(PARA)==4:
			filnamn=dirg+str(PARA[3])
		else:
			filnamn=dirg+"volume"
	elif str(PARA[0])=='pll':
		if len(PARA)==4:
			filnamn=dirg+str(PARA[3])
		else:
			filnamn=dirg+"pll"
	elif str(PARA[0])=='spe':
		if len(PARA)==5:
			filnamn=dirg+str(PARA[4])
		else:
			filnamn=dirg+"special"
	else:
		print 'This option dose not exists'
	print 'Used inputfile is '+str(filnamn)
	fil=open(filnamn,'r')
	for l in fil:
		b.append(l.split(',')[0])
		C.append(l.split(',')[1:])
	fil.close()
	B.append(b)
	b.insert(0,'scenario')
	Cmin.append(b)
	Cmax.append(b)
	C=np.array(C,dtype=float)
	fil=open(str(G[0])+"simulations.csv",'r')
        b=0
	GG=False
	if str(PARA[1])=='>':
		sign=1.0
	elif str(PARA[1])=='<':
		sign=-1.0
	else:
		print 'Higher or lower than the limit has to be specified'
	bc=float(PARA[2])*sign
        for l in fil:
		if GG:
			r3dfil=str(l.split(',')[1])
			print r3dfil
			d=os.path.split(r3dfil)[0]
			vol=0
			b,cmin,cmax=volum_s(PARA[0],l.split(',')[0],d,C,vari,bc,PARA[3],sign)
			B.append(b)
			Cmin.append(cmin)
			Cmax.append(cmax)
		else:
			GG=True
	np.savetxt(os.path.join(str(G[0])+'Cmin'+str(PARA[0])+'_'+str(aa[:-1])+string+'_'+vari+'.csv'),Cmin,fmt="%s",delimiter=',')
	np.savetxt(os.path.join(str(G[0])+'Cmax'+str(PARA[0])+'_'+str(aa[:-1])+string+'_'+vari+'.csv'),Cmax,fmt="%s",delimiter=',')
	if vari=='RA35':
		vari='heat'
	if str(PARA[0])=='pll':
		srad=str(G[0])+'simulations_fire_pll_'+str(aa[:-1])+string+'_'+vari+'.csv'
	elif str(PARA[0])=='vol':
		srad=str(G[0])+'simulations_fire_volume_'+str(aa[:-1])+string+'_'+vari+'.csv'
	else:	
		srad=str(G[0])+'simulations_fire_special_'+str(aa[:-1])+string+'_'+vari+'.csv'	
	with open(srad, 'wb') as fd:
		writer = csv.writer(fd)
		for l in B:
			writer.writerow(l)
def exploref(AREA,LEAKC,PARA,graph,string,vari):
	for a in AREA:
		for l in LEAKC:
			pacalc(a,l,PARA,graph,string,vari)
################################################ EXPLORE #####################################################
def ecalc2(graph,efil,outname,endp,crit,sign):
	NAMES=[]
	string=''
	i=0
	F=False
	FF=False
	with open(graph+'startNodesAndNames.csv','r') as f:
		output = f.read()
		for o in output.split('\n'):
			if len(o.split(','))==2 and F:
				if FF:
					string+=','
				string+='\"'+str(o.split(',')[0])+'\"'
				FF=True
				i+=1
			F=True
		string+='\n'
	MAX_ESC=np.zeros((3000))
	Bil,N,sk2,sk3=imp_esc(efil,crit,sign,MAX_ESC)
	A=connect_ar(graph,endp)
	for i in range(len(Bil)):
		B=Bil[i]
		string+='\"'+str(N[i])+'\"'
		for j in range(len(output.split('\n'))-1):
			lista=[]
			o=output.split('\n')[j+1]
			if len(o.split(','))==2:
				T=True
				lista.append(int(o.split(',')[1]))
				T=doe_p(A,int(o.split(',')[1]),B,T,lista,endp)
				if str(lista[-1])!=str(endp):
					string+=',Inf'
				else:
					string+=',1'
		string+='\n'
	fil=open(outname,'w')
	fil.write(string)
	fil.close()
#Bil,N,sk2,sk3=imp_esc(efil,float(LEAKC[3]),str(LEAKC[2]),MAX_ESC)
#imp_esc(efil,crit,sign,MAX_ESC):
#doe_p(A,pkt,B,T,lista,endp):
			# Ali: rymingsvagar fran 0-315
			# str(graph): EINPUT/
			# efil: P250/25kg/EXPLOR_R3D/max_rad_in_escape_routes_.csv
			# float(LEAKC[3]):  6300
			# Bil : rymnigsvagar med value>6300 / scenaio
			# A: empty
			# endp: 315
#			string=calc_loe(Ali,str(graph),efil,float(LEAKC[3]),Bil,A,endp,A,A)
def ecalc(a,l,graph,PARA):
	G=[]
	if str(a[-1])=='/':	
		aa=a
		a=a[:-1]
	else:	
		aa=a+'/'
	if str(l[-1])=='/':	
		ll=l
	else:	
		ll=l+'/'
	if str(graph[-1])!='/':	
		graph=graph+'/'
	dird=os.getcwd()+'/'+aa+ll
	dirg=os.getcwd()+'/'+graph
	G.append(os.getcwd()+'/'+aa+ll+'EXPLOR_R3D/')
	G.append(os.getcwd()+'/'+aa+ll+'EXPLOR_R3D/RAD/')
	G.append(os.getcwd()+'/'+aa+ll+'EXPLOR_R3D/VIS/')
	for g in G:
		make_dir(g)
	find('scenario_RA35_exit.r3d','scenario_sight_exit.r3d',dird,str(G[0]))
	os.system("python /home/sung-hoon/RUBY/Fire/setup_fire/1109987708/Fire/bin/generate_stdr3d.py -s "+str(G[0])+"simulations.csv -g "+graph+"newGrid.dat -k rad -f 0 -o "+str(G[1]))
	os.system("python /home/sung-hoon/RUBY/Fire/setup_fire/1109987708/Fire/bin/generate_stdr3dMin.py -s "+str(G[0])+"simulations.csv -g "+graph+"newGrid.dat -k vis -f 0 -o "+str(G[2]))
	lisr3d(str(G[0])+'list_rad.list',str(G[1]))
	lisr3d(str(G[0])+'list_vis.list',str(G[2]))
	os.system('python /home/sung-hoon/RUBY/Fire/setup_fire/1109987708/Fire/bin/volume_exposure.py -o '+str(G[0])+'max_rad_in_escape_routes_.csv -v '+graph+'escape.kfx -f 0 -r '+str(G[0])+'list_rad.list')
	os.system('python /home/sung-hoon/RUBY/Fire/setup_fire/1109987708/Fire/bin/volume_exposure.py -i -o '+str(G[0])+'min_vis_in_escape_routes_.csv -v '+graph+'escape.kfx -f 0 -r '+str(G[0])+'list_vis.list')
	fil=open(graph+'endnode','r')
	for l in fil:
		if isnumeric(l.split()[0]):
			endp=int(l.split()[0])
	fil.close()
	fil=open(graph+'loe','r')
	for f in fil:
		if len(f.split())==2:
			PARA.append(f.split()[0])
			PARA.append(f.split()[1])
	fil.close()
        print G, a, endp, PARA
	ecalc2(graph,str(G[0])+'min_vis_in_escape_routes_.csv',str(G[0])+'simulations_fire'+str(a)+'_escape_sight_area_center.csv',endp,float(PARA[4]),str(PARA[3]))
	ecalc2(graph,str(G[0])+'max_rad_in_escape_routes_.csv',str(G[0])+'simulations_fire'+str(a)+'_escape_heat_area_center.csv',endp,float(PARA[2]),str(PARA[1]))
def lisr3d(name,di):	
	simfil=''
	for root, dirs, files in os.walk(di):
		for f in files:
			a=os.path.join(root, f)
	   		simfil+=str(a)+'\n'
	fil=open(name,'w')
	fil.write(simfil)
	fil.close()
def find(name_heat,name_vis, path,p):
	simfil='id,rad,vis\n'
	for root, dirs, files in os.walk(path):
		b=os.path.join(root, name_vis)
		if name_heat in files and os.path.isfile(b):
			bb=root.split('/')
			bc=bb[-1]
			bn=bb[-3]
			name=str(bc.split('_')[1])+'_'
			name+=str(bb[-4])+'_'
			name+=str(bb[-2])+'_'
			name+=str(bn[:-2])
			a=os.path.join(root, name_heat)
			simfil+=name+','+a+','+b+'\n'
	csvfil(p+'simulations.csv',simfil)
def explore(AREA,LEAKC,graph,PARA):
	for a in AREA:
		for l in LEAKC:
			ecalc(a,l,graph,PARA)
################# Frequency weighted #####################
def calc_pos(r,LEAKC,c,escal):
#	print 'XXXXXXXX'
#	print r
#	print LEAKC
#	print c
	if ESCAL:
		r=r+escal
	for j in range(len(LEAKC)-1):
		m1=float(LEAKC[j])
		m2=float(LEAKC[j+1])
		c1=float(c[j+1])
		c2=float(c[j+2])
		if m1<r and r<=m2:
			c_out=c1-(c1-c2)*(r-m1)/(m2-m1)	
	if c_out <0:
		c_out=0
	return c_out
def leakfz(area,LEAKC,B,UNRATE,graph,WT,string,vari,escal,G1):
	#leakfz(a,LEAKC,B,UNRATE,graph,'',string,vari,escal)
	b=B[0]
	A=[]
	AA=[]
	C=[]
	FZ=[]
	Pfz_g=[]
	Pfz_gtot=np.zeros((4))
	Pfz_lq=[]
	Pfz_lqtot=np.zeros((4))
	LEAK_C=[]
	sec=10
	for leak in LEAKC:
		LEAK_C.append(leak)
	nleakcat=len(UNRATE)
	for i in range(len(LEAK_C)):
		if str(LEAK_C[i][-1])=='/':
			LEAK_C[i]=float(LEAK_C[i][:-3])
		else:
			LEAK_C[i]=float(LEAK_C[i][:-2])
	LEAK_C.append(0.0)
	LEAK_C.append(10000.0)
	LEAK_C.sort()
	GAS=np.zeros((4,len(B)))
	LQ=np.zeros((4,len(B)))
	for i in range(len(B)):
		d=[]
		d.append(B[i])
		d.append(0.0)
		for k in range(nleakcat):
			d.append(float(UNRATE[k][i]))
		if WT=='vol':
			filx=open(graph+'volume')
			for l in filx:	
				vol_t=(float(l.split(',')[4])-float(l.split(',')[1]))*(float(l.split(',')[5])-float(l.split(',')[2]))*(float(l.split(',')[6])-float(l.split(',')[3]))
			fact=(d[-1]-d[-2])/(LEAK_C[-2]-LEAK_C[-3])
			M=d[-2]-fact*LEAK_C[-3]
			volu=fact*LEAK_C[-1]+M
			if volu>vol_t:
				volu=vol_t
			d.append(volu)
		else:
			d.append(1.0)
		C.append(d)
	print C
	fil=open(graph+'leakfz','r')
	i=0
	GG=False
	data=fil.readlines()
	fil.close()
	fzg=np.zeros((4))
	fzlq=np.zeros((4))
	for ll in data:
		line=ll.split('\r')[0]
		if GG:
			d=[]
			for obj in line.split(','):
				d.append(float(obj))
			dim_leakf=len(d)
			FZ.append(d)
			i+=1
		if str(line)==str(area) or str(line)==str(area[:-1]) or str(line)==str(area)+'\n' or str(line)==str(area[:-1])+'\n':
			GG=True
		elif i==3:
			GG=False
			i=0
	if str(area[-1])=='/':
		afz='leakfz_'+str(area[:-1])
		rate_gas=np.zeros((dim_leakf))
		rate_lq=np.zeros((dim_leakf))
	else:
		afz='leakfz_'+str(area)
	if os.path.isfile(graph+afz):
		print 'Transient leak correction is included'
		fil=open(graph+afz,'r')
		data=fil.readlines()
		fil.close()
		GG=True
		GT=True
		TGAS=True
		num_seg=0
		i_old=0
		for ll in data:
			line=ll.split('\r')[0]
			if not GG and GT and isnumeric(ll.split(',')[0]) and str(ll.split(',')[0])!='0.1':
				index=int(ll.split(',')[0])-1
				rate=FZ[0][index]
				if 0.0<rate and rate<=1.0:
					leak_num=0
				elif 1.0<rate and rate<=10.0:
					leak_num=1
				elif 10.0<rate and rate<=30.0:
					leak_num=2
				elif 30.0<rate:
					leak_num=3
				m=0
				m=rate/float(sec+1)
				if len(ll.split(','))>=(sec+2):
					sec_n=sec
				else:
					sec_n=len(ll.split(','))-3
				for jjj in range(sec_n):
					m+=float(ll.split(',')[jjj+2])/float(sec+1)
				if TGAS:	
					rate_gas[index]+=m*Pfz_g[num_seg][leak_num]/Pfz_gtot[leak_num]
				else:
					rate_lq[index]+=m*Pfz_lq[num_seg][leak_num]/Pfz_lqtot[leak_num]
				if index==(dim_leakf-1):
					num_seg+=1
					if num_seg==len(Pfz_g) and TGAS:
						TGAS=False
						num_seg=0	
			if len(ll.split(','))==5 and GG:
				d=float(ll.split(',')[1]),float(ll.split(',')[2]),float(ll.split(',')[3]),float(ll.split(',')[4])
				if i_old>=float(ll.split(',')[0]):
					GT=False
				if GT:	
					Pfz_g.append(d)
					Pfz_gtot[0]+=d[0]
					Pfz_gtot[1]+=d[1]
					Pfz_gtot[2]+=d[2]
					Pfz_gtot[3]+=d[3]
				else:	
					Pfz_lq.append(d)
					Pfz_lqtot[0]+=d[0]
					Pfz_lqtot[1]+=d[1]
					Pfz_lqtot[2]+=d[2]
					Pfz_lqtot[3]+=d[3]
				i_old=float(ll.split(',')[0])		 
			elif str(ll.split(',')[0])=='0.1' and len(ll.split(','))==2:
				GG=False
				GT=True
			else:
				GG=False
				
	else:
		print 'Transient leak correction is \033[1mNOT\033[0;0m included'
	for i in range(dim_leakf):
		rate=FZ[0][i]
		if 0.0<rate and rate<=1.0:
			leak_num=0
			fzg[0]=fzg[0]+FZ[1][i]
			fzlq[0]+=FZ[2][i]
		elif 1.0<rate and rate<=10.0:
			leak_num=1
			fzg[1]+=FZ[1][i]
			fzlq[1]+=FZ[2][i]
		elif 10.0<rate and rate<=30.0:
			leak_num=2
			fzg[2]+=FZ[1][i]
			fzlq[2]+=FZ[2][i]
		elif 30.0<rate:
			leak_num=3
			fzg[3]+=FZ[1][i]
			fzlq[3]+=FZ[2][i]
 		for j in range(len(B)):
			if os.path.isfile(graph+afz):
				num_gas=calc_pos(rate_gas[i],LEAK_C,C[j],escal)
				num_lq=calc_pos(rate_lq[i],LEAK_C,C[j],escal)
				GAS[leak_num][j]+=num_gas*FZ[1][i]	
				LQ[leak_num][j]+=num_lq*FZ[2][i]	
			else:
				num=calc_pos(rate,LEAK_C,C[j],escal)
				GAS[leak_num][j]+=num*FZ[1][i]	
				LQ[leak_num][j]+=num*FZ[2][i]	
	for i in range(len(B)):
		for j in range(4):
			if fzg[j]!=0:
				GAS[j][i]=GAS[j][i]/fzg[j]
			if fzlq[j]!=0:
				LQ[j][i]=LQ[j][i]/fzlq[j]
	
	ESC1=False
	if escal>0:
		ESC1=True
	if WT=='spe':
		sdas=str(os.getcwd())+'/'+area[:-1]+string+'_spec_'+vari+'_final.csv'
		g1='spec_'+vari+string
	elif WT=='pll':
		sdas=str(os.getcwd())+'/'+area[:-1]+string+'_pll_'+vari+'_final.csv'
		g1='pll_'+vari+string
	elif WT=='all':
		sdas=str(os.getcwd())+'/'+area[:-1]+string+'_all_'+vari+'_final.csv'
		g1='all_'+vari+string
	elif WT=='all2':
		sdas=str(os.getcwd())+'/'+area[:-1]+string+'_all_'+vari+'_final.csv'
		g1='all2_'+vari+string
	elif WT=='vol':
		sdas=str(os.getcwd())+'/'+area[:-1]+string+'_volume_'+vari+'_final.csv'
		g1='volume_'+vari+string
	elif WT=='rad':
		sdas=str(os.getcwd())+'/'+area[:-1]+string+'_heat_final.csv'
		g1='loe_rad'
	elif WT=='':
		sdas=str(os.getcwd())+'/'+area[:-1]+string+'_sight_final.csv'
		g1='loe_sight'
	G1=transformg(area,GAS,g1,B,'gas',G1,ESC1) 
	G1=transformg(area,LQ,g1,B,'liq',G1,ESC1)
	with open(sdas, 'wb') as fd:
		writer = csv.writer(fd)
		writer.writerow(B)
               	for l in GAS:
			writer.writerow(l)
               	for l in LQ:
			writer.writerow(l)
	return G1
def transformg(area,G,name,T,typ,A,E): 
	C=['small','medium','major','large']
	for j in range(len(G)):
		g=G[j]
		for i in range(len(T)):
			A.append([area[:-1],E,typ,name,C[j],T[i].rstrip(),g[i]])
	return A
def transforml(a,T,C,L,target,G3):
	for j in range(len(L)):
		for i in range(len(T)):
			G3.append([a[:-1],target,L[j][:-3],T[i].rstrip(),C[j][i]])
	return G3
def Pfactor(l,Wp,LD,leak_dir,Ip):
	scenario=int(l.split('_')[0])
	wind_dir=str(l.split('_')[2])

	ws=l.split('_')[3]
	wspeed=float(ws)
	w=ign_w(Ip,Wp)
	for i in range(len(LD)):
		if int(1+i*leak_dir)<=scenario and scenario<=int(leak_dir+i*leak_dir):
			f_area=float(LD[i])
	if wind_dir=='NORTH':
		k=1
	elif wind_dir=='SOUTH':
		k=2
	elif wind_dir=='EAST':
		k=3
	elif wind_dir=='WEST':
		k=4
	for i in range(len(w)):
		if float(w[i][0])==wspeed:
			f_wind=float(w[i][k])
	f_leakd=1.0/float(leak_dir)
	f_scen=f_leakd*f_wind*f_area
	return f_scen				
def wind(W,WIND,length):
        #print(length)
	w=np.zeros((length,5))	
	i=0
	if length>1:
		for i in range(length-1):
			w[i][0]=float(WIND[i])+(float(WIND[1+i])-float(WIND[i]))/2
	w[-1][0]=100.0
	for obj in W:
		ff=True
		for i in range(length):	
			if w[i][0]>=float(obj[0]) and ff:
				ff=False
				w[i][1]+=float(obj[1])
				w[i][2]+=float(obj[2])
				w[i][3]+=float(obj[3])
				w[i][4]+=float(obj[4])
	for i in range(length):
		w[i][0]=WIND[i]
	return w
def readfil_pll(area,srad,w,LD,SCEN,leak_dir,n1,G2,Ip):
	RAD=[]
	B=[]
	RAD=np.genfromtxt(srad,dtype=str,delimiter=',')
	B=RAD[0]
	B=B[1:]
	RAD=RAD[1:]	
	size=B.shape[0]
	A=np.zeros((size))
	for e in range(len(RAD)):
		o=RAD[e]
		s=o[0]
		l=s.split('/')[-1]
		g2=[]
		ll=l
		f_scen=Pfactor(ll,w,LD,leak_dir,Ip)
		g2.append(detail_leak(area,ll,n1,f_scen))
		nre_scen=0
		for obj in SCEN:
			if str(obj[1])==str(ll):
				f_extra=Pfactor(str(obj[0]),w,LD,leak_dir,Ip)
				g2.append(detail_leak(area,obj[0],n1,f_extra))
				f_scen+=f_extra
				nre_scen+=1
		for g in range(o.shape[0]-1):
			A[g]=A[g]+f_scen*float(o[1+g])
			if float(o[1+g])>0:
				G2.append(np.append(np.append(g2[0][:-1],B[g]),g2[0][-1]))
				if len(g2)>=2:
					for j in range(nre_scen):
						G2.append(np.append(np.append(g2[1+j][:-1],B[g]),g2[1+j][-1]))
	return A,B,G2
def readfil_vol(area,srad,w,LD,SCEN,leak_dir,n1,G2):
	T=False
	RAD=[]
	B=[]
	G2[0][-1]='Volume [m3]'	
	with open(srad,'r') as f:
		output = f.read()
		for o in output.split('\n'):
			if T and len(o)>0:
				RAD.append(o)
			else:
				T=True
				for b in o.split(','):
					if len(b)>0:	
						if str(b[0])=='"':
							B.append(b[1:-1])
						else:
							B.append(b)
	line=str(RAD[0])
	size=len(line.split(','))
	A=np.zeros((size))
	for e in range(len(RAD)):
		o=RAD[e]
		s=o.split(',')[0]
		l=s.split('/')[-1]
		g2=[]
		ll=l
		f_scen=Pfactor(ll,w,LD,leak_dir)
		g2.append(detail_leak(area,ll,n1,f_scen))
		for obj in SCEN:
			if str(obj[1])==str(ll):
				f_extra=Pfactor(str(obj[0]),w,LD,leak_dir)
				g2.append(detail_leak(area,obj[0],n1,f_extra))
				f_scen+=f_extra
		for g in range(len(o.split(','))-1):
			A[g]=A[g]+f_scen*float(o.split(',')[1+g])
			g22=(g2[0][:-1])
			g22.append(B[g].rstrip())
			g22.append(float(o.split(',')[1+g]))
			G2.append(g22)
			if len(g2)==2:
				g22=(g2[1][:-1])
				g22.append(B[g].rstrip())
				g22.append(float(o.split(',')[1+g]))
				G2.append(g22)
	return A,B,G2
def create_geo(path,graph,MAX_ESC,NAME_ESC,outfil,time):
	size_be=500
	fout=os.path.join(path,outfil)
	node=os.path.join(graph,'nodecords.csv')
	cs=open(node,'r')
	csn=cs.readlines()
	cs.close()
	text=''
	A=[]
	for l in csn:
		if len(l.split(','))==4:
			name=int(l.split(',')[0])
			x=float(l.split(',')[1])*1000
			y=float(l.split(',')[2])*1000
			z=float(l.split(',')[3])*1000
			A.append([name,x,y,z])
			if TIME:
				if int(l.split(',')[0]) in time:
					i=np.where(time==int(l.split(',')[0]))[0][0]
					text+='COLOR: 0 0 0\nPART: rbg 1 0 0\nBOX: %4.4f'%(x-200)+' %4.4f'%(y-200)+' %4.4f'%(z-200)+' 800.0000 800.0000 800.000\n'+'COLOR: 0 0 1\nPART: rbg 0 0 1\nTEXT: %4.4f'%(x/1000)+' %4.4f'%(y/1000)+' %4.4f'%((z+700)/1000)+' '+str(i)+'\n'
				else:
					text+='COLOR: 0 0 0\nPART: rbg 1 0 0\nBOX: %4.4f'%(x-200)+' %4.4f'%(y-200)+' %4.4f'%(z-200)+' 800.0000 800.0000 800.000\n'
			else:
				text+='COLOR: 0 0 0\nPART: rbg 1 0 0\nBOX: %4.4f'%x+' %4.4f'%y+' %4.4f'%(z+300)+' 300.0000 300.0000 -300.000\n'+'COLOR: 0 0 1\nPART: rbg 0 0 1\nTEXT: %4.4f'%(x/1000)+' %4.4f'%(y/1000)+' %4.4f'%((z+400)/1000)+' '+str(name)+'\n'
	for i in range(len(MAX_ESC)):
		n=NAME_ESC[i]
		value=float(MAX_ESC[i])
		i1=int(n.split('_')[1])
		i2=int(n.split('_')[2])
		X=[]
		Y=[]
		Z=[]
		TT=True
		j=0
		while TT:
			if int(A[j][0])==i1 or int(A[j][0])==i2:
				X.append(A[j][1])
				Y.append(A[j][2])
				Z.append(A[j][3])
			if len(X)==2 and len(Y)==2 and len(Z)==2:
				TT=False
			if TIME:
				if i1 in time and i2 in time and value==0:
					value=0.45
				
			j+=1
		if value<0.1:
			cl='0.0 0.0 0.0'	
		elif 0.1<=value and value<0.2:
			cl='0.0 0.4 0.0'	
		elif 0.2<=value and value<0.3:
			cl='0.0 0.0 1.0'	
		elif 0.3<=value and value<0.4:
			cl='0.0 0.90 0.93'	
		elif 0.4<=value and value<0.5:
			cl='0.20 1.0 0.20'	
		elif 0.5<=value and value<0.6:
			cl='1.0 0.50 0.06'	
		elif 0.6<=value and value<0.7:
			cl='1.0 0.84 0.0'	
		elif 0.7<=value and value<0.8:
			cl='1.0 0.11 0.68'	
		elif 0.8<=value and value<=1.0:
			cl='1.0 0.0 0.0 '	
		text+='COLOR: '+cl+'\nPART: rbg 1 0 0\nSBOX: %4.4f'%(X[0]+250)+' %4.4f'%(Y[0]+250)+' %4.4f'%(Z[0]+250)+' %4.4f'%(X[1]+250)+' %4.4f'%(Y[1]+250)+' %4.4f'%(Z[1]+250)+' '+str(size_be)+' '+str(size_be)+'\n'
	f=open(fout,'w')
	f.write(text)
	f.close()
	text="-------------------------------\nRadG\nQT Probability of LOE ()\n                 1 0 0\n     0.8\n                 1.0 0.11 0.68\n     0.7\n                 1.0 0.84 0.0\n     0.6\n                 1.0 0.50 0.06\n     0.5\n                 0.20 1.0 0.20\n     0.4\n                 0.0 0.90 0.93\n     0.3\n                 0.0 0.0 1.0\n     0.2\n                 0.0 0.4 0.0\n     0.1\n                 0.0 0.0 0.0\n     0.0\n                 0.0 0.0 0.0\n-------------------------------\nFILE=liz.jnk\n"
	fout=os.path.join(path,'leg.jnk')
	f=open(fout,'w')
	f.write(text)
	f.close()
########################## check loe #################################################################
def doe_p(A,pkt,B,T,lista,endp):
 	return loe_p(A,pkt,B,T,lista,endp)	
def loe_p(A,pkt,B,T,lista,endp):
	i=0
	C=A[pkt]
	for a in C:
		if a not in lista:
			u1=(a,pkt)
			u2=(pkt,a)
			if a==endp:	
				lista.append(a)	
				T=False
			elif (not u1 in B) and (not u2 in B):
				lista.append(a)	
				T=doe_p(A,a,B,T,lista,endp)
		if not T:
			break
	return T
			# Ali: rymingsvagar fran 0-315
			# str(graph): EINPUT/
			# efil: P250/25kg/EXPLOR_R3D/max_rad_in_escape_routes_.csv
			# float(LEAKC[3]):  6300
			# Bil : rymnigsvagar med value>6300 / scenaio
			# A: empty
			# endp: 315
#			string=calc_loe(Ali,str(graph),efil,float(LEAKC[3]),Bil,A,endp,A,A)
def calc_loe(A,graph,efil,bound,B,STARTP,endp,N,E):
	C=[]
	string=''
	if OPTI:
		i=0
		for bb in B:
			b=list(bb)
			for e in E:
				if e in b:
					b.remove(e)
			string=str(N[i])
#			string+=str(N[i])
			i+=1
			for s in STARTP:
				lista=[]
				lista.append(int(s))
				T=True
				T=doe_p(A,s,b,T,lista,endp)
				if T:
					string+=',Inf'
				else:
					string+=',1'
			C.append(string)	
#			string+='\n'	
		return C
	else:
		NAMES=[]
		with open(graph+'startNodesAndNames.csv','r') as f:
			output = f.read()
			for o in output.split('\n'):
				if len(o.split(','))==2:
					NAMES.append(o.split(',')[0])
		print output
		for j in range(len(output.split('\n'))-1):
			lista=[]
			o=output.split('\n')[j+1]
			if len(o.split(','))==2:
				T=True
				lista.append(int(o.split(',')[1]))
				T=doe_p(A,int(o.split(',')[1]),B,T,lista,endp)
				if str(lista[-1])!=str(endp):
					string+=str(NAMES[j+1])+':, '+str(lista)+',Dead\n'
				else:
					string+=str(NAMES[j+1])+':, '+str(lista)+'\n'
	#	fil.close()
		return string			
######################################################################################################
#16_25kg_EAST_12
def single_field_outp(LEAKC,graph,time):
	A=[]
	tot_dir=os.path.split(str(LEAKC[0]))[0]
	res_dir=str(tot_dir.split('/')[-5])+'/'+str(tot_dir.split('/')[-4])+'/EXPLOR_R3D/'
	na1=str(tot_dir.split('/')[-1])
	snr=na1.split('_')[1]
	w_dir=str(tot_dir.split('/')[-2])
	na1=str(tot_dir.split('/')[-3])
	ws=na1[:-2]
	leakc=str(tot_dir.split('/')[-4])
	sname=snr+'_'+leakc+'_'+w_dir+'_'+ws
	fil=open(graph+'endnode','r')
	for f in fil:
		if len(f)>=1:
			endp=int(f) 
	fil.close()
	if TIME:
		ostein=os.getcwd()+'/'+str(LEAKC[0].split('/')[0])+'/'+str(LEAKC[0].split('/')[1])+'/EXPLOR_R3D/RAD/'+str(LEAKC[0].split('/')[4].split('_')[1])+'_'+str(LEAKC[0].split('/')[1])+'_'+str(LEAKC[0].split('/')[3])+'_'+str(LEAKC[0].split('/')[2].split('ms')[0])+'.r3d'
		NodeA=csvtoarray_str(os.getcwd(),'Time_'+str(tot_dir.split('/')[-5])+'.csv')
		sub=NodeA[np.where(NodeA[:,0]==ostein)]
		sub=sub[np.where(sub[:,6]==time[0])]
		print time
		time=sub[np.where(sub[:,10]==time[1])][0][-1]
		time=time.split()
		time=np.array(time)
		time=time.astype(int)
	if str(LEAKC[1])=='rad':
		ostein=os.getcwd()+'/'+str(LEAKC[0].split('/')[0])+'/'+str(LEAKC[0].split('/')[1])+'/EXPLOR_R3D/RAD/'+str(LEAKC[0].split('/')[4].split('_')[1])+'_'+str(LEAKC[0].split('/')[1])+'_'+str(LEAKC[0].split('/')[3])+'_'+str(LEAKC[0].split('/')[2].split('ms')[0])+'.r3d'
		efil=os.path.join(res_dir,'max_rad_in_escape_routes_.csv')
	elif str(LEAKC[1])=='vis':
		ostein=os.getcwd()+'/'+str(LEAKC[0].split('/')[0])+'/'+str(LEAKC[0].split('/')[1])+'/EXPLOR_R3D/VIS/'+str(LEAKC[0].split('/')[4].split('_')[1])+'_'+str(LEAKC[0].split('/')[1])+'_'+str(LEAKC[0].split('/')[3])+'_'+str(LEAKC[0].split('/')[2].split('ms')[0])+'.r3d'
		efil=os.path.join(res_dir,'min_vis_in_escape_routes_.csv')
	elif str(LEAKC[1])=='both':
		ostein=os.getcwd()+'/'+str(LEAKC[0].split('/')[0])+'/'+str(LEAKC[0].split('/')[1])+'/EXPLOR_R3D/RAD/'+str(LEAKC[0].split('/')[4].split('_')[1])+'_'+str(LEAKC[0].split('/')[1])+'_'+str(LEAKC[0].split('/')[3])+'_'+str(LEAKC[0].split('/')[2].split('ms')[0])+'.r3d'
		efil=os.path.join(res_dir,'max_rad_in_escape_routes_.csv')
		efili=os.path.join(res_dir,'min_vis_in_escape_routes_.csv')
		rad_sign=sign(LEAKC[2])
		vis_sign=sign(LEAKC[4])
		fili=open(efili,'r')
		VIS=fili.readlines()
		fili.close()
	else:
		print 'Wrong input'
	Ali=connect_ar(graph,endp)
        print '1550', efil
	fil=open(efil,'r')
        print '1552',fil
	F=True
	inte=0
	for f in fil:
		B=[]
		na1=str(f.split(',')[0])
		na2=os.path.basename(na1)
		cname=na2.split('.')[0]
                print 'for f in fil'
		if F:
			F=False
			a=f.split(',')[1:]
			MAX_ESC=np.zeros((len(a))) 
			Bil,sk1,sk2,sk3=imp_esc(efil,float(LEAKC[3]),str(LEAKC[2]),ostein)
                        print 'in F'
		elif sname == cname:
			for i in range(len(f.split(','))-1):
				c=a[i]
				B.append((int(c.split('_')[1]),int(c.split('_')[2]),float(f.split(',')[i+1])))
				if TIME:
					g=VIS[inte] 
					if float(f.split(',')[i+1])*rad_sign>=float(LEAKC[3])*rad_sign and float(g.split(',')[i+1])*vis_sign>=float(LEAKC[5])*vis_sign:
						MAX_ESC[i]=1.0
					elif float(f.split(',')[i+1])*rad_sign>=float(LEAKC[3])*rad_sign:
						MAX_ESC[i]=0.75
					elif float(g.split(',')[i+1])*vis_sign>=float(LEAKC[5])*vis_sign:
					#	print float(f.split(',')[i+1])*rad_sign,float(g.split(',')[i+1])*vis_sign
						MAX_ESC[i]=0.65
					else:
						MAX_ESC[i]=0.0
					
				else:
					if str(LEAKC[2])=='>':
						if float(f.split(',')[i+1])>=float(LEAKC[3]):
							MAX_ESC[i]=1.0
						else:
							MAX_ESC[i]=0.0
					elif str(LEAKC[2])=='<':
						if float(f.split(',')[i+1])<=float(LEAKC[3]):
							MAX_ESC[i]=1.0
						else:
							MAX_ESC[i]=0.0
                        print 'in sname'
			string=calc_loe(Ali,str(graph),efil,float(LEAKC[3]),Bil,A,endp,A,A)
                        print string
		inte+=1
	fil.close()	
	efil=os.path.join(res_dir,sname+'_'+str(LEAKC[1])+'.csv')
	fil=open(efil,'w')
        print '1598', efil
        print string
	fil.write(string)
	fil.close()
	create_geo(res_dir,graph,MAX_ESC,a,sname+'_'+str(LEAKC[1])+'.kfx',time)
######################################################################################################
def connect_ar(graph,endp):
	Ali=[]
	with open(graph+'connectivity.csv','r') as f:
		fil = f.readlines()
	for i in range(len(fil)):
		a=[]
		for f in fil:
			if len(f.split(','))==2:
				if i == int(f.split(',')[0]):
					a.append(int(f.split(',')[1]))
				elif i == int(f.split(',')[1]):
					a.append(int(f.split(',')[0]))
		Ali.append(a)
	return Ali
def find_escape(srad,WT,w,LD,SCEN,leak_dir,graph,string,MAX_ESC):
	A=[]
	Ali=[]
	N=[]
	B=[]
	Bil=[]
	C=[]
	CRES=[]
	D=[]
	P=[]
	PROB=[]
	Q=[]
	fil=open(graph+'endnode','r')
	for f in fil:
		if len(f)>=1:
			endp=int(f) 
	fil.close()
	STARTP=[]
	area=str(string[0])
	with open(graph+'startNodesAndNames.csv','r') as f:
		output = f.read()
		for o in output.split('\n'):
			if len(o.split(','))==2:
				if re.match(area, str(o.split()[0])):
					STARTP.append(int(o.split(',')[1]))	
					B.append(str(o.split(',')[0]))
	for b in B:
		if str(b.split('_')[0]) not in C:
			C.append(str(b.split('_')[0]))
			D.append(False)
			CRES.append(0.0)
	for c in C:
		if str(c[:-1]) not in P:
			P.append(str(c[:-1]))
			Q.append(False)
	size=len(P)
#	print STARTP
	Ali=connect_ar(graph,endp)
	if WT=='rad':
		efil=os.path.join(os.path.dirname(srad),'max_rad_in_escape_routes_.csv')
		Bil,N,EIN,PROB=imp_esc(efil,float(string[3]),str(string[2]),MAX_ESC)
	elif WT=='':
		efil=os.path.join(os.path.dirname(srad),'min_vis_in_escape_routes_.csv')
		Bil,N,EIN,PROB=imp_esc(efil,float(string[3]),str(string[2]),MAX_ESC)
	num_e=int(round(len(EIN)*0.4))
	SOLVE=True
	while SOLVE:
		A=np.zeros((size))
		eut=random_esc(EIN,PROB,num_e)
#		eut=[]
		RAD=calc_loe(Ali,graph,efil,'>',Bil,STARTP,endp,N,eut)
		for e in range(len(RAD)):
			o=RAD[e]
			s=o.split(',')[0]
			l=s.split('/')[-1]
			tt=[]
			if str(l[-1])=='"':
				ll=l[:-1]
			else:
				ll=l
			f_scen=Pfactor(ll,w,LD,leak_dir)
			for obj in SCEN:
				if str(obj[1])==str(ll):
					f_extra=Pfactor(str(obj[0]),w,LD,leak_dir)
					f_scen+=f_extra
			for g in range(len(o.split(','))-1):
				if ('Inf'!=str(o.split(',')[1+g]) and 'Inf\n'!=str(o.split(',')[1+g]) and 'Inf\r'!=str(o.split(',')[1+g])):
					for i in range(len(C)):
						b=B[g]
						if str(C[i])==str(b.split('_')[0]):
							D[i]=True
			for i in range(len(C)):
				if not D[i]:
					CRES[i]+=f_scen
					for p in range(size):
						cn=C[i]
						if str(P[p])==str(cn[:-1]):
							Q[p]=True
				else:
					D[i]=False
			for p in range(size):
				if Q[p]:
					A[p]=A[p]+f_scen
					Q[p]=False
		print str(A)+','+str(len(eut))+','+str(eut)
#			if float(A)<=0.0:
#				SOLVE=False

#	elif WT=='':
#		efil=os.path.join(os.path.dirname(srad),'min_vis_in_escape_routes_.csv')
#		B=imp_esc(efil)
#		C=calc_loe(Ali,graph,efil,4,'<',B,STARTP,endp)

#Bil,sk1,sk2,sk3=imp_esc(efil,float(LEAKC[3]),str(LEAKC[2]),MAX_ESC)
def imp_esc(efil,crit,sigh,MAX_ESC):
	fil=open(efil,'r')
	a=[]
	A=[]
	B=[]
	E=[]
	N=[]
	RES=''
#	print len(MAX_ESC)
	P=np.array([])
	F=True
	T=True
	tot_valv=0.0
	factor=sign(sigh)
	for f in fil:
		if F:
			F=False
			a=f.split(',')[1:]
		else:
			A=[]
			n=str(f.split(',')[0])
			N.append(str(n.split('.')[0]))
			for i in range(len(f.split(','))-1):
				c=a[i]
				T=False
				if crit*factor<float(f.split(',')[i+1])*factor:
					p=(int(c.split('_')[1]),int(c.split('_')[2]))
					A.append(p)
					if p not in E and not SCE:
						E.append(p)
						tot_valv+=MAX_ESC[i]
						P=np.append(P,tot_valv)
				
			if SCE:
				if str(MAX_ESC)==str(n):
					B=list(A)
			else:
				B.append(A)
	if not SCE and tot_valv!=0.0:
		RES = P * (1/tot_valv)
	return B,N,E,RES
def random_esc(EIN,PROB,num_e):
	A=[]
	T=True
	num_s=int(round(random.betavariate(2,5)*num_e)+1)
#	num_s=random.randrange(1,num_e)
	while T:
		r=random.random()
		i=find_nearest(PROB,r)
		b=EIN[i]			
		if b not in A:
			A.append(b)
		if len(A)==num_s:
			T=False
	return A
def csolve(EIN,i):
	combos = itertools.combinations(EIN, i)
	usable_combos = []
	for e in combos:
		usable_combos.append(e)

	return usable_combos
######################################################################################################
def readfil_all2(area,srad,WT,w,LD,SCEN,leak_dir,graph,n1,str2,G2,Ip):
	C=[]
	C1=[]
	P=[]
	MAX_ESC=[]
	PARA=[]
	tt_text=''
	dt_dres=''
	RAD=np.genfromtxt(srad,dtype=str,delimiter=',')
	B=RAD[0]
	RAD=RAD[1:]
	B=B[1:]	
	D1=np.zeros(B.shape[0])	
	for b in B:
		C1.append(str(b.split('_')[0]))
		if str(b.split('_')[0]) not in C:
			C.append(str(b.split('_')[0]))
	C=np.array(C)
	C1=np.array(C1)
	size=C.shape[0]
	A=np.zeros((1))
	for e in range(RAD.shape[0]):
		o=RAD[e]
		s=o[0]
		l=s.split('/')[-1]
		tt=[]
		g2=[]
		if str(l[-1])=='"':
			ll=l[:-1]
		else:
			ll=l
		f_scen=Pfactor(ll,w,LD,leak_dir,Ip)
		g2.append(detail_leak(area,ll,n1,f_scen))
		nre_scen=0
		for obj in SCEN:
			if str(obj[1])==str(ll):
				f_extra=Pfactor(str(obj[0]),w,LD,leak_dir,Ip)
				f_scen+=f_extra
				g2.append(detail_leak(area,obj[0],n1,f_extra))
				nre_scen+=1
		for g in range(o.shape[0]-1):
			b=B[g]
			if ('Inf'==str(o[1+g])):
				D1[g]=1
		f_tot=1
		for i in range(C.shape[0]):
			dc=D1[np.where(C1==C[i])[0]]
			f=0
			if dc.sum()>0:
				f=1
			f_tot=f_tot*f
		if f_tot==1:
			print o
			G2.append(np.append(np.append(g2[0][:-1],[str2]),g2[0][-1]))
			if len(g2)>=2:
				for j in range(nre_scen):
					G2.append(np.append(np.append(g2[1+j][:-1],[str2]),g2[1+j][-1]))
			A[0]=A[0]+f_scen
		D1[:]=0
#	print G2
	C=np.array([str2])
	return A,C,G2
def readfil_all(area,srad,WT,w,LD,SCEN,leak_dir,graph,n1,G2,Ip):
	C=[]
	C1=[]
	P=[]
	MAX_ESC=[]
	PARA=[]
	tt_text=''
	dt_dres=''
	RAD=np.genfromtxt(srad,dtype=str,delimiter=',')
	B=RAD[0]
	RAD=RAD[1:]
	B=B[1:]	
	D1=np.zeros(B.shape[0])	
	for b in B:
		C1.append(str(b.split('_')[0]))
		if str(b.split('_')[0]) not in C:
			C.append(str(b.split('_')[0]))
	C=np.array(C)
	C1=np.array(C1)
	size=C.shape[0]
	A=np.zeros((size))
	for e in range(RAD.shape[0]):
		o=RAD[e]
		s=o[0]
		l=s.split('/')[-1]
		tt=[]
		g2=[]
		if str(l[-1])=='"':
			ll=l[:-1]
		else:
			ll=l
		f_scen=Pfactor(ll,w,LD,leak_dir,Ip)
		g2.append(detail_leak(area,ll,n1,f_scen))
		nre_scen=0
		for obj in SCEN:
			if str(obj[1])==str(ll):
				f_extra=Pfactor(str(obj[0]),w,LD,leak_dir,Ip)
				f_scen+=f_extra
				g2.append(detail_leak(area,obj[0],n1,f_extra))
				nre_scen+=1
		for g in range(o.shape[0]-1):
			b=B[g]
			if ('Inf'==str(o[1+g])):
				D1[g]=1
		for i in range(C.shape[0]):
			dc=D1[np.where(C1==C[i])[0]]
			if dc.shape[0]==dc.sum():
				G2.append(np.append(np.append(g2[0][:-1],C[i]),g2[0][-1]))
				if len(g2)>=2:
					for j in range(nre_scen):
						G2.append(np.append(np.append(g2[1+j][:-1],C[i]),g2[1+j][-1]))
				A[i]=A[i]+f_scen
		D1[:]=0
#	print G2
	return A,C,G2
def readfil(area,srad,WT,w,LD,SCEN,leak_dir,graph,n1,G2,Ip):
	T=False
	RAD=[]
	B=[]
	C=[]
	CRES=[]
	D=[]
	P=[]
	Q=[]
	MAX_ESC=[]
	PARA=[]
	tt_text=''
	dt_dres=''
	RAD=np.genfromtxt(srad,dtype=str,delimiter=',')
	B=RAD[0]
	RAD=RAD[1:]
	B=B[1:]	
	for b in B:
		if str(b.split('_')[0]) not in C:
			C.append(str(b.split('_')[0]))
			D.append(False)
			CRES.append(0.0)
	C=np.array(C)
	size=C.shape[0]
	A=np.zeros((size))
	for e in range(RAD.shape[0]):
		o=RAD[e]
		print o
		s=o[0]
		l=s.split('/')[-1]
		tt=[]
		g2=[]
		if str(l[-1])=='"':
			ll=l[:-1]
		else:
			ll=l
		f_scen=Pfactor(ll,w,LD,leak_dir,Ip)
		g2.append(detail_leak(area,ll,n1,f_scen))
		nre_scen=0
		for obj in SCEN:
			if str(obj[1])==str(ll):
				f_extra=Pfactor(str(obj[0]),w,LD,leak_dir,Ip)
				f_scen+=f_extra
				g2.append(detail_leak(area,obj[0],n1,f_extra))
				nre_scen+=1
		for g in range(o.shape[0]-1):
			b=B[g]
			if ('Inf'==str(o[1+g])) and ((WT=='spe') or (WT=='spe')):
				D[np.where(C==b.split('_')[0])[0]]=True
			elif WT=='all':
				print 'function does not exists'
		for i in range(size):
			if D[i]:
				G2.append(np.append(np.append(g2[0][:-1],C[i]),g2[0][-1]))
				if len(g2)>=2:
					for j in range(nre_scen):
						G2.append(np.append(np.append(g2[1+j][:-1],C[i]),g2[1+j][-1]))
				A[i]=A[i]+f_scen
				D[i]=False
	return A,C,G2
def detail_leak(area,scen,target,p):
	a=scen.split('_')
	pos=int(a[0])
	F=True
	i=-1
	while F:
		i+=1
		if 6+6*i>=pos and pos>6*i:
			F=False
			pos-=6*i
	return [area,target,scen,i,a[1][:-2],pos,a[3],a[2],p]
def calc(a,l,W,graph,WT,string,vari,G2):
	G=[]
	WIND=[]
	LD=[]
	SCEN=[]
	Ip=[]
	TR=False
	TL=False
	if vari=='RA35':
		vari='heat'
	if str(a[-1])=='/':	
		aa=a
	else:	
		aa=a+'/'
	if str(l[-1])=='/':	
		ll=l
	else:	
		ll=l+'/'
	T=False
	dird=os.getcwd()+'/'+aa+ll
	G.append(os.getcwd()+'/'+aa+ll+'EXPLOR_R3D/')
	G.append(os.getcwd()+'/'+aa+ll+'EXPLOR_R3D/RAD/')
	G.append(os.getcwd()+'/'+aa+ll+'EXPLOR_R3D/VIS/')
	srad=G[0]+'simulations_fire'+a[:-1]+'_escape_heat_area_center.csv'	
	svis=G[0]+'simulations_fire'+a[:-1]+'_escape_sight_area_center.csv'	
	if not OPTI:
		spll=str(G[0])+'simulations_fire_pll_'+str(aa[:-1])+string+'_'+vari+'.csv'
		svol=str(G[0])+'simulations_fire_volume_'+str(aa[:-1])+string+'_'+vari+'.csv'
		sspe=str(G[0])+'simulations_fire_special_'+str(aa[:-1])+string+'_'+vari+'.csv'
	dirg=os.getcwd()+'/'+graph
	fil=open(dirg+'data','r')
	leak_dir=6
	for f in fil:
		if len(f.split())==2 and str(f.split()[0])=='Area:':
			if (str(f.split()[1])==aa or str(f.split()[1])==aa[:-1]):
				TR=True
			else:
				TR=False
		if len(f.split())==2 and str(f.split()[0])=='LeakR:':
			if (str(f.split()[1])==ll or str(f.split()[1])==ll[:-1]):
				TL=True
			else:
				TL=False
		if len(f.split())>=2 and TR and TL:
			if str(f.split()[0])=='Winds:':	
				for i in range(len(f.split())-1):
					WIND.append(f.split()[i+1])
			if str(f.split()[0])=='LeakD:':	
				for i in range(len(f.split())-1):
					LD.append(f.split()[i+1])
			if str(f.split()[0])=='IgnP:':	
				for i in range(len(f.split())-1):
					Ip.append(f.split()[i+1])
			if str(f.split()[0])=='Leak_dir:':	
				leak_dir= float(f.split()[1])
		if len(f.split())==2 and TR and TL:
			SCEN.append([str(f.split()[0]),str(f.split()[1])])
                #print f, TR, TL
                #print WIND
                #print LD
                #print Ip
                #print SCEN
	fil.close()
	Ip=np.array(Ip,dtype=float)
	if Ip.shape[0]==0:
		Ip=np.ones(4)
	w=wind(W,WIND,len(WIND))
	if not OPTI:
		if os.path.exists(srad) and os.path.exists(svis) and WT=='':
			UNVAL,B,G2=readfil(aa[:-1],svis,WT,w,LD,SCEN,leak_dir,graph,'loe_sight',G2,Ip)
		elif os.path.exists(srad) and WT=='rad':
			UNVAL,B,G2=readfil(aa[:-1],srad,WT,w,LD,SCEN,leak_dir,graph,'loe_rad',G2,Ip)
		elif os.path.exists(sspe) and WT=='spe':
			UNVAL,B,G2=readfil(aa[:-1],sspe,WT,w,LD,SCEN,leak_dir,graph,'spec'+string+'_'+vari,G2,Ip)
		elif os.path.exists(sspe) and WT=='all':
			UNVAL,B,G2=readfil_all(aa[:-1],sspe,WT,w,LD,SCEN,leak_dir,graph,'all'+string+'_'+vari,G2,Ip)
		elif os.path.exists(sspe) and WT=='all2':
			UNVAL,B,G2=readfil_all2(aa[:-1],sspe,WT,w,LD,SCEN,leak_dir,graph,'all2'+string+'_'+vari,'All'+string,G2,Ip)
		elif os.path.exists(spll) and WT=='pll':
			UNVAL,B,G2=readfil_pll(aa[:-1],spll,w,LD,SCEN,leak_dir,'pll'+string+'_'+vari,G2,Ip)
		elif os.path.exists(svol) and WT=='vol':
			UNVAL,B,G2=readfil_vol(aa[:-1],svol,w,LD,SCEN,leak_dir,'vol'+string+'_'+vari,G2,Ip)
		else:
			print srad+' dose not exist'

		return UNVAL,B,G2
	else:
		if 'vis'==str(string[1]):
			WT=''
			MAX_ESC=readfil(aa[:-1],svis,WT,w,LD,SCEN,leak_dir,graph,'',[])
		elif 'rad'==str(string[1]):
			WT='rad'
			MAX_ESC=readfil(aa[:-1],srad,WT,w,LD,SCEN,leak_dir,graph,'',[])
		find_escape(svis,WT,w,LD,SCEN,leak_dir,graph,string,MAX_ESC)
def w_a_q(AREA,LEAKC,graph,WT,TT,string,vari,escal):
	#w_a_q(AREA,LEAKC,graph,WT,TT,string,vari,escal)
	W=[]
	Fz=[]
	UNRATE=[]
	UNRATE2=[]
	if str(graph[-1])!='/':	
		graph=graph+'/'
	dirg=os.getcwd()+'/'+graph
	fil=open(dirg+'weather','r')
	for f in fil:
		if len(f.split())==5:
			if isnumeric(f.split()[0]) and isnumeric(f.split()[1]) and isnumeric(f.split()[2]) and isnumeric(f.split()[3]) and isnumeric(f.split()[4]):
				W.append([float(f.split()[0]),float(f.split()[1]),float(f.split()[2]),float(f.split()[3]),float(f.split()[4])])
	fil.close()
	for a in AREA:
		G1=[['Area of fire','Escalated Fire','Leak type','Target type','Leak category','Target','Probability of impairment']]
		G2=[['Area of fire','Target type','Scenario name','Leak point','Leak rate','Leak dir','Wind speed','Wind dir','Target','Probability of impairment']]
		G3=[['Area of fire','Target type','Leak rate','Target','Probability of impairment']]
		UNRATE=[]
		UNRATE2=[]
		UNVAL=[]
		for l in LEAKC:
			if OPTI:
				if 'rad'==string[1]:
					calc(a,l,W,graph,'rad',string,vari,G2)
				elif 'vis'==string[1]:
					calc(a,l,W,graph,'vis',string,vari,G2)
			else:
				if WT=='loe':
					UNVAL,B,G2=calc(a,l,W,graph,'rad',string,vari,G2)
					UNRATE2.append(UNVAL)
					UNVAL,B,G2=calc(a,l,W,graph,'',string,vari,G2)
					UNRATE.append(UNVAL)
				else:
	
					UNVAL,B,G2=calc(a,l,W,graph,WT,string,vari,G2)
					UNRATE.append(UNVAL)
		if not OPTI:
			if TT:
				if WT=='loe':
					G1=leakfz(a,LEAKC,B,UNRATE2,graph,'rad',string,vari,escal,G1)
					G1=leakfz(a,LEAKC,B,UNRATE,graph,'',string,vari,escal,G1)
					n3='loe_rad'
					G3=transforml(a,B,UNRATE2,LEAKC,n3,G3)
					n3='loe_sight'
				else:
					G1=leakfz(a,LEAKC,B,UNRATE,graph,WT,string,vari,escal,G1)
			G1=np.array(G1)
			esc=''
			if escal>0:
				esc='_esc'
			if WT=='spe':
				sdas=str(os.getcwd())+'/'+a[:-1]+string+'_'+vari+'_special.csv'
				n1=a[:-1]+string+'_'+vari+esc+'_special.csv'
				n3='spes_'+vari
			elif WT=='pll':
				sdas=str(os.getcwd())+'/'+a[:-1]+string+'_'+vari+'_pll.csv'
				n1=a[:-1]+string+'_'+vari+esc+'_pll.csv'
				n3='pll_'+vari
			elif WT=='all':
				sdas=str(os.getcwd())+'/'+a[:-1]+string+'_'+vari+'_all.csv'
				n1=a[:-1]+string+'_'+vari+esc+'_all.csv'
				n3='all_'+vari
			elif WT=='all2':
				sdas=str(os.getcwd())+'/'+a[:-1]+string+'_'+vari+'_all2.csv'
				n1=a[:-1]+string+'_'+vari+esc+'_all2.csv'
				n3='all2_'+vari
			elif WT=='vol':
				sdas=str(os.getcwd())+'/'+a[:-1]+string+'_'+vari+'_volume.csv'
				n1=a[:-1]+string+'_'+vari+esc+'_volume.csv'
				n3='vol_'+vari
			elif WT=='loe':
				sdas=str(os.getcwd())+'/'+a[:-1]+string+'.csv'
				n1=a[:-1]+string+'_'+esc+'_loe.csv'
			G3=transforml(a,B,UNRATE,LEAKC,n3,G3)
			G3=np.array(G3)
			np.savetxt('Impprob_'+n1,G1, delimiter=",",fmt="%s")
			np.savetxt('ScenImp_'+n1,G2, delimiter=",",fmt="%s")
			np.savetxt('Leakprob_'+n1,G3, delimiter=",",fmt="%s")
		        with open(sdas, 'wb') as fd:
	       	 	        writer = csv.writer(fd)
				writer.writerow(B)
       	        		for line in UNRATE:
					writer.writerow(line)
				if WT=='loe':
					writer.writerow('rad')
       	        			for line in UNRATE2:	
						writer.writerow(line)
def tot_res(d):
	G1=[['Area of fire','Escalated Fire','Leak type','Target type','Target','Leak category','Probability of impairment']]
	G2=[['Area of fire','Target type','Scenario name','Leak point','Leak rate','Leak dir','Wind speed','Wind dir','Target','Probability of impairment']]
	G3=[['Area of fire','Target type','Leak rate','Target','Probability of impairment']]
	d=os.path.abspath(d)
	tot_resex(d,'Impp',G1,'IMPPROB')
	tot_resex(d,'ScenI',G2,'SCENIMP')
	tot_resex(d,'Leakprob',G3,'LEAKPROB')
def tot_resex(d,string,G1,outname):
	dum,F=findfile(d,'(.*)'+string+'(.*).csv$')
	print outname
	for f in F:
		print f
		A=np.genfromtxt(f, dtype=str, delimiter=',')	
		if len(A.shape)==2:
			G1=np.append(G1,A[1:],axis=0)
	G1=np.array(G1)
	if G1.shape[0]>1:
		np.savetxt(outname+'_total.csv',G1, delimiter=",",fmt="%s")
################################ Create folder struck ########################################################
def c_folder(AREA,LEAKC):
	for a in AREA:
		if str(a[-1])=='/':
			a_jet=str(a[:-1])+'_JET/'
			a_pool=str(a[:-1])+'_POOL/'
		else:
			a_jet=str(a)+'_JET/'
			a_pool=str(a)+'_POOL/'
		make_dir(a_jet)
		make_dir('EINPUT/')
		make_dir(a_pool)
		for l in LEAKC:
			T=False
			if len(l)==1 and isnumeric(l):
				T=True
				l=l+'kg/'
			elif len(l)==2:
				if isnumeric(l):
					T=True
					l=l+'kg/'
				elif isnumeric(l[0]) and str(l[1])=='/':
					T=True
					l=str(l[0])+'kg/'
			elif len(l)==3:
				if isnumeric(l):
					T=True
					l=l+'kg/'
				elif isnumeric(l[-3:-1]) and str(l[-1])=='/':
					T=True
					l=str(l[-3:-1])+'kg/'
				elif isnumeric(l[-3]) and str(l[-2:])=='kg':
					T=True
					l=str(l)+'/'
			elif len(l)>3:
				if isnumeric(l):
					T=True
					l=l+'kg/'
				elif str(l[-3:])=='kg/' and isnumeric(l[-4]):
					l=str(l)
					T=True
				elif str(l[-2:])=='kg' and isnumeric(l[-3]):	
					l=str(l)+'/'
					T=True
			if T:
				make_dir(a_jet+l)
				make_dir(a_jet+l+'LeakP_A/')
				make_dir(a_jet+l+'LeakP_B/')
				make_dir(a_jet+l+'LeakP_C/')
#				make_dir(a_jet+l+'LeakP_D/')
#				make_dir(a_jet+l+'LeakP_E/')
				make_dir(a_pool+l)
				make_dir(a_pool+l+'LeakP_A/')
				make_dir(a_pool+l+'LeakP_B/')
				make_dir(a_pool+l+'LeakP_C/')
			else:
				print 'The leak categorie has to be eather a number or number + kg e.i 10 or 10kg'
######################################### Test esapce route network ################################################
def route_to_geo(gname,N,C,S,E,X,end):
	text=''
	A=[]
	if X.shape[0]==0:
		X=np.array([[0,0]])
	for e in E:
		A.append([e,end])
	A=np.array(A)
	for n in N:
		text+='COLOR: 1 0 0\nPART: rbg 1 0 0\nBOX: %4.4f'%(n[1]*1000)+' %4.4f'%(n[2]*1000)+' %4.4f'%(n[3]*1000+300)+' 300.0000 300.0000 -300.000\n'+'COLOR: 0 0 1\nPART: rbg 0 0 1\nTEXT: %4.4f'%n[1]+' %4.4f'%n[2]+' %4.4f'%(n[3]+0.3)+' '+str(int(n[0]))+'\n'
	for c in C:
		d=list(c)
		d.reverse()
		n=N[c[0]]*1000
		n1=N[c[1]]*1000
		if np.all(c==A,axis=1).any() or np.all(d==A,axis=1).any():
#			print str(c[0])+','+str(c[1])+',e,'
			text+='COLOR: 0 0 1\nPART: '+str(c[0])+' '+str(c[1])+' \nSBOX: %4.4f'%n[1]+' %4.4f'%n[2]+' %4.4f'%n[3]+' %4.4f'%n1[1]+' %4.4f'%n1[2]+' %4.4f'%n1[3]+' 100.0 100.0\n'
		elif np.all(c==S,axis=1).any() or np.all(d==S,axis=1).any():
#			print str(c[0])+','+str(c[1])+',s,'
			text+='COLOR: 0 1 0\nPART: '+str(c[0])+' '+str(c[1])+' \nSBOX: %4.4f'%n[1]+' %4.4f'%n[2]+' %4.4f'%n[3]+' %4.4f'%n1[1]+' %4.4f'%n1[2]+' %4.4f'%n1[3]+' 100.0 100.0\n'
		elif np.all(c==X,axis=1).any() or np.all(d==X,axis=1).any():
#			print str(c[0])+','+str(c[1])+',x,'
			text+='COLOR: 0 0 0\nPART: '+str(c[0])+' '+str(c[1])+' \nSBOX: %4.4f'%n[1]+' %4.4f'%n[2]+' %4.4f'%n[3]+' %4.4f'%n1[1]+' %4.4f'%n1[2]+' %4.4f'%n1[3]+' 100.0 100.0\n'
		else:
			text+='COLOR: 1 0 0\nPART: '+str(c[0])+' '+str(c[1])+' \nSBOX: %4.4f'%n[1]+' %4.4f'%n[2]+' %4.4f'%n[3]+' %4.4f'%n1[1]+' %4.4f'%n1[2]+' %4.4f'%n1[3]+' 100.0 100.0\n'
	wtextf(gname,text)
def map_imp2kfx(path,typ,sign,value):
	print typ
	W=[]
	if typ=='rad':
		sfil='max_rad_in_escape_routes_.csv'
	if typ=='vis':
		sfil='min_vis_in_escape_routes_.csv'
	F=findfiles(os.path.abspath(path),sfil)
	NodeA=csvtoarray('EINPUT','nodecords.csv')
	ConA=csvtoarray('EINPUT','connectivity.csv')	
	Data=csvtoarray_str('EINPUT','data')
	Wind=csvtoarray_str('EINPUT','weather')
	for i in Wind:
		W.append([float(i.split()[0]), float(i.split()[1]),float(i.split()[2]),float(i.split()[3]),float(i.split()[4])])
	Wind=list(W)
	for f in F:
		print f
		p=os.path.split(f)[0]
		A=np.genfromtxt(f, dtype=str, delimiter=',')	
		dL=A[0,1:]
		dL=fixdl(dL)
		S=A[1:,0]
		I=impperpart(A,sign,value)
		print I.shape,I.sum(axis=0).max()
		S=getprob_per_scen(p,S,Data,Wind)
		T=probperpart(I,S)
		t=prob2kfx(NodeA,dL,T)
		wtextf(os.path.join(p,typ+'.kfx'),t)
	text="-------------------------------\nRadG\nQT Probability of LOE ()\n                 1 0 0\n     0.8\n                 1.0 0.11 0.68\n     0.7\n                 1.0 0.84 0.0\n     0.6\n                 1.0 0.50 0.06\n     0.5\n                 0.20 1.0 0.20\n     0.4\n                 0.0 0.90 0.93\n     0.3\n                 0.0 0.0 1.0\n     0.2\n                 0.0 0.4 0.0\n     0.1\n                 0.0 0.0 0.0\n     0.0\n                 0.0 0.0 0.0\n-------------------------------\nFILE=liz.jnk\n"
	wtextf('leg.jnk',text)
def prob2kfx(NodeA,dL,T):
	t=''
	for i in range(dL.shape[0]):
		d=dL[i]	
		t+=kfx_color(T[i],str(d[0])+'_'+str(d[1]))
		C=NodeA[d]*1000.
		t+='SBOX: %4.4f'%C[0,1]+' %4.4f'%C[0,2]+' %4.4f'%C[0,3]+' %4.4f'%C[1,1]+' %4.4f'%C[1,2]+' %4.4f'%C[1,3]+' 200. 200.\n'
	return t	
def kfx_color(value,string):
	if value<0.001:
		cl='0.0 0.0 0.0'	
	elif 0.001<=value and value<0.1:
		cl='0.2 0.2 0.2'	
	elif 0.1<=value and value<0.2:
		cl='0.0 0.4 0.0'	
	elif 0.2<=value and value<0.3:
		cl='0.0 0.0 1.0'	
	elif 0.3<=value and value<0.4:
		cl='0.0 0.90 0.93'	
	elif 0.4<=value and value<0.5:
		cl='0.20 1.0 0.20'	
	elif 0.5<=value and value<0.6:
		cl='1.0 0.50 0.06'	
	elif 0.6<=value and value<0.7:
		cl='1.0 0.84 0.0'	
	elif 0.7<=value and value<0.8:
		cl='1.0 0.11 0.68'	
	elif 0.8<=value and value<=1.0:
		cl='1.0 0.0 0.0 '
	else:
		print 'error: value above 1:',value
	return 'COLOR: '+cl+'\nPART: '+string+'\n'
def probperpart(I,S):
	I=I.transpose()
	A=S*I
	A=A.transpose()
	return A.sum(axis=0)		
def getprob_per_scen(p,S,Data,Wind):
	D=get_data(p.split('/')[-3],p.split('/')[-2],Data,Wind)
	P=[]
	for s in S:
		P.append(probscen(os.path.splitext(os.path.split(s)[1])[0],D[0],D[1],D[2],D[4]))
	P=np.array(P,dtype=float)
	return P		
def impperpart(A,sign,value):
	V=A[1:,1:]
	value=float(value)
	V=V.astype(float)
	I=np.zeros((V.shape))
	if sign=='>':
		print 'heat'
		print I[np.where(V>=float(value))].shape		
		I[np.where(V>=value)]=1.0		
	if sign=='<':
		I[np.where(V<=value)]=1.0		
	return I
def fixdl(A):
	B=[]
	for a in A:
		B.append([a.split('_')[1],a.split('_')[2]])	
	B=np.array(B,dtype=int)
	return B
def sens2geo(fname):
	p=os.path.split(fname)[0]
	f=os.path.split(fname)[1]
	Node=csvtoarray(p,'nodecords.csv')
	NodeA=csvtoarray(p,'nodecords.csv')
	ConA=csvtoarray(p,'connectivity.csv')	
	SconA=csvtoarray(p,'safe_connections.csv')	
	end=int(csvtoarray(p,'endnode'))
	SconA=SconA.astype(int)
	ConA=ConA.astype(int)
	end_nr=end
	NodeA,end=endnode1(NodeA,ConA,end)
	S=csvtoarray_str(p,f)
	S=reshape(S)
	s=S[0]
	safe,end1,ConA,X=scen_con(s[1:],SconA,list(end),end_nr,ConA)
	gname=os.path.join(os.getcwd(),'Geo_'+str(s[0])+'_'+f+'.kfx')
	route_to_geo(gname,Node,ConA,safe,end1,X,end_nr)
def w_a_q2(AREA,LEAKC,path,graph,filename,es,stra):
	NodeA=csvtoarray(graph,'nodecords.csv')
	Node=np.copy(NodeA)	
	ConA=csvtoarray(graph,'connectivity.csv')	
	SconA=csvtoarray(graph,'safe_connections.csv')	
	Start=csvtoarray_str(graph,'startNodesAndNames.csv')	
	Fz_data=testftostr(graph,'leakfz')	
	Data=csvtoarray_str(graph,'data')
	Wind=csvtoarray_str(graph,'weather')
	W=[]
	B=[]
	A=[]
	AA=[]
	if len(path)>0:
		AAAA=findfiles(os.path.abspath(path),'max_rad_in_escape_routes_.csv')
		for aa in AAAA:
			A.append([aa.split('/')[-4],aa.split('/')[-3][:-2]]) 
		A=np.array(A)
		for a in np.unique(A[:,0]):
			b=A[np.where(A[:,0]==a),1]
			b=b.astype(int)
			b.sort()
			b=np.append(a,b)
			AA.append(b)
	#Scen_imp=[['Scenario name','Area of fire','Wind direction','Wind speed [m/s]','Leak direction','Leak rate [kg/s]','Main area','Deck level','Heat or sight']]
	Scen_imp=[['Area of fire','Target type','Scenario name','Leak point','Leak rate','Leak dir','Wind speed','Wind dir','Target','Probability of impairment']]
	B=[['Area of fire','Target type','Leak rate','Target','Probability of impairment']]
	#Bfz=[['Sensitivity','Area of fire','Main area','Leak category','Probability of impairment heat gas [-]','Probability of impairment sight gas [-]','Probability of impairment heat spray [-]','Probability of impairment sight spray [-]']]
	Bfz=[['Area of fire','Escalated Fire','Leak type','Target type','Target','Leak category','Probability of impairment']]
	for i in Wind:
		W.append([float(i.split()[0]), float(i.split()[1]),float(i.split()[2]),float(i.split()[3]),float(i.split()[4])])
	Wind=list(W)
	end=int(csvtoarray(graph,'endnode'))
	end_nr=end
	loe=csvtoarray_str(graph,'loe')
	S=csvtoarray_str(graph,filename[0])
	a=[]
	for l in loe:
		a.append([sign(l.split()[0]),float(l.split()[1])],)
	loe=list(a)	
	ConA=ConA.astype(int)
	SconA=SconA.astype(int)
	Dmat,C=dist_matrix(NodeA,ConA)
	string=''
	NodeA,end=endnode1(NodeA,ConA,end)
	NodeB=svensk(Dmat,Node,end,C)
	S=reshape(S)
	for s in S:
		safe,end1,ConA,X=scen_con(s[1:],SconA,list(end),end_nr,ConA)
		gname=os.path.join(os.getcwd(),'Geo_'+str(s[0])+'_'+filename[0]+'.kfx')
		route_to_geo(gname,Node,ConA,safe,end1,X,end_nr)
		if len(AA)>0:
			for si in AA:
				a=str(si[0])+'/'
				bb=[]
				LEAKC=si[1:]
				for l in LEAKC:
					l=str(l)+'kg/'
					Marea,ProbA,Scen_imp=etq(a,l,NodeB,safe,end1,loe,Start,C,Dmat,Node,Data,Wind,Scen_imp,X)
					b=[s[0],a[:-1],l[:-3]]
					k=0
					for p in ProbA:
						B.append([a[:-1],'loe_rad',l[:-3],Marea[k],p[0]])
						B.append([a[:-1],'loe_sight',l[:-3],Marea[k],p[1]])
						b.append(p[0])	
						b.append(p[1])	
						k+=1
					bb.append(b[2:])
				bb=np.array(bb,dtype=float)	
				if len(filename)==2:
					bb=insert_pimp(graph,filename[1],bb)
				Bfz=fz_wegit(s[0],a[:-1],Marea,bb,Fz_data,Bfz,es,graph)
		else:
			for a in AREA:
				bb=[]
				for l in LEAKC:
					Marea,ProbA,Scen_imp=etq(a,l,NodeB,safe,end1,loe,Start,C,Dmat,Node,Data,Wind,Scen_imp,X)
					b=[s[0],a[:-1],l[:-3]]
					k=0
					for p in ProbA:
						B.append([a[:-1],'loe_rad',l[:-3],Marea[k],p[0]])
						B.append([a[:-1],'loe_sight',l[:-3],Marea[k],p[1]])
						b.append(p[0])	
						b.append(p[1])	
						k+=1
					bb.append(b[2:])
				bb=np.array(bb,dtype=float)
				if len(filename)==2:
					bb=insert_pimp(graph,filename[1],bb)
				Bfz=fz_wegit(s[0],a[:-1],Marea,bb,Fz_data,Bfz,es,graph)
	Bprob=np.array(B)
	Bfz=np.array(Bfz)
	Bfz=Bfz[:,[0,1,2,3,5,4,6]]
	Scen_imp=np.array(Scen_imp)
	prname=os.path.join(os.getcwd(),'Leakprob_'+filename[0]+stra+'.csv')
	fzname=os.path.join(os.getcwd(),'Impprob_'+filename[0]+stra+'.csv')
	scname=os.path.join(os.getcwd(),'ScenImp_'+filename[0]+stra+'.csv')
	np.savetxt(prname,Bprob, delimiter=",",fmt="%s")
	np.savetxt(fzname,Bfz, delimiter=",",fmt="%s")
	np.savetxt(scname,Scen_imp, delimiter=",",fmt="%s")
def insert_pimp(path,filen,A):
	B=csvtoarray_str(path,filen)
	B=B[1:]
	B=B.astype(float)
	for i in range(B.shape[0]):
		b=B[i]
		po=np.where(A[:,0]>b[0])[0]
		if len(po)==0:
			nr_raws,nr_col=A.shape
			nr_raws+=1
			A=np.append(A,b)
			A=A.reshape(nr_raws,nr_col)
		else:
			A=np.insert(A,po[0],b,axis=0)
	return A 
def scen_con(A,S,E,nr,ConA):
	X=[]
	for i in range(len(A)/3):
		if str(A[3*i+2])=='s':
			s=[[int(A[3*i]),int(A[3*i+1])]]
			S=np.append(S,s,axis=0)
		elif str(A[3*i+2])=='x':
			X.append([int(A[3*i]),int(A[3*i+1])])
		elif str(A[3*i+2])=='e':
			s=[[int(A[3*i]),int(A[3*i+1])]]
			ConA=np.append(ConA,s,axis=0)
			if int(A[3*i+1])==nr:
				E.append(int(A[3*i]))
			else:	
				E.append(int(A[3*i+1]))
	X=np.array(X)
	return S,E,ConA,X
def edit_max_min(X,MaxR,MinV):
	MaxR=np.array(MaxR)
	MinV=np.array(MinV)
	for x in X:
		s1='Escape_'+str(x[0])+'_'+str(x[1])
		s2='Escape_'+str(x[1])+'_'+str(x[0])
		ix=np.where(MaxR[0]==s1)[0]
		if ix.shape[0]==0:
			ix=np.where(MaxR[0]==s2)[0]
		if ix.shape[0]==1:
			MaxR[1:,ix[0]]='10000000'
			MinV[1:,ix[0]]='0'
		else:	
			print 'error connection:',s1,s2
	#np.savetxt('Amax.csv',MaxR,fmt="%s",delimiter=',')
	#np.savetxt('Amin.csv',MinV,fmt="%s",delimiter=',')
	return MaxR,MinV	
#Marea,ProbA,Scen_imp,Start_imp=etq(a,l,NodeB,safe,end1,loe,Start,C,Dmat,Node,Data,Wind,Scen_imp,Start_imp,X)
def etq(a,l,NodeA,SconA,end,loe,Start,C,Dmat,Node,Data,Wind,Scen_imp,X):
	U=[]
	P=0.0
	d=os.path.join(os.getcwd(),a)
	d=os.path.join(d,l)
	d=os.path.join(d,'EXPLOR_R3D')
	MaxR=csvtoarray_str(d,'max_rad_in_escape_routes_.csv')	
	MinV=csvtoarray_str(d,'min_vis_in_escape_routes_.csv')
	if X.shape[0]>0:
		MaxR,MinV=edit_max_min(X,MaxR,MinV)	
	ename=np.array(MaxR[0][1:])
	length_NodeA=len(NodeA)
	Outside=[]
	loe1=np.copy(loe)
	loe2=np.copy(loe)
	loe1[0][1]=np.inf
	loe2[1][1]=-1*np.inf
	D=get_data(a[:-1],l[:-1],Data,Wind)
	First=True
	print a,l
	SPoints=np.zeros((Start.shape[0]-1,4))	
	for r in range(len(MaxR)-1):
		mr=np.array(MaxR[r+1][1:])
		IMP=[]
		scen=MaxR[r+1][0]
		mr=mr.astype(float)
		mv=np.array(MinV[r+1][1:])
		mv=mv.astype(float)
		for i in range(len(Start)-1):
			I=int(Start[i+1][1])
			name=Start[i+1][0]
			W=[I]
			F=False
			G=False
			time=time_out=0.0
			cord=NodeA[I][-1]
			if I not in end:
				#time,time_out,W,F=walkway(I,NodeA,SconA,end,loe2,mr,mv,W,ename,F,time,Outside,time_out)
				time,time_out,W,F=walkway(I,NodeA,SconA,end,loe2,mr,mr,W,ename,F,time,Outside,time_out)
				W=[I]
			#	if I==61 and  scen=='/nfs/projects05/104724/fire/DP/SIM/DC111_311_JET/50kg/EXPLOR_R3D/RAD/8_50kg_EAST_5.r3d':
			#		print 'start'
				time,time_out,W,G=walkway(I,NodeA,SconA,end,loe1,mv,mv,W,ename,G,time,Outside,time_out)
				#print W
			#	if I==61 and  scen=='/nfs/projects05/104724/fire/DP/SIM/DC111_311_JET/50kg/EXPLOR_R3D/RAD/8_50kg_EAST_5.r3d':
			else:
				F=True
				G=True
			if not F:
				SPoints[i,0]+=1
				SPoints[i,1]+=probscen(os.path.splitext(os.path.split(scen)[1])[0],D[0],D[1],D[2],D[4])
			if not G:
				SPoints[i,2]+=1
				SPoints[i,3]+=probscen(os.path.splitext(os.path.split(scen)[1])[0],D[0],D[1],D[2],D[4])
			IMP.append((name.split('_')[0][:-1],name.split('_')[0],name.split('_')[1],float(F),float(G)))
		IMP=np.array(IMP)
		if First:
			Marea=np.unique(IMP[:,0])
			ProbA=np.zeros((len(np.unique(IMP[:,0])),2))
			First=False
		proba,dP,Scen_imp=concequenc_calc(a,l,os.path.splitext(os.path.split(scen)[1])[0],D,IMP,Scen_imp)
		P+=dP
		i=0
		for pr in proba:
			ProbA[i]+=pr
			i+=1
	SPoints=np.append(Start[1:],SPoints,axis=1)	
	SPoints=np.append([['area_name','node','Heat #','Heat probability','Sight #','Sight probability']],SPoints,axis=0)	
	np.savetxt('StartPprob_'+a[:-1]+'_'+l[:-1]+'.csv',SPoints,fmt="%s",delimiter=',')
	print 'Total probability:',P
	return Marea,ProbA,Scen_imp
def concequenc_calc(area,l,scen,D,IMP,Scen_imp):
	LP=int(scen.split('_')[0])
	wd=str(scen.split('_')[2])
	ws=float(scen.split('_')[3])
	s=D[3]
	A=[]
	Pscen=probscen(scen,D[0],D[1],D[2],D[4])
	if len(s)>0:
		for si in s[np.where(s[:,1]==scen)[0],0]:
			Pscen+=probscen(si,D[0],D[1],D[2],D[4])
	Marea=np.unique(IMP[:,0])
	for ma in Marea:
		p1=IMP[np.where(IMP[:,0]==ma)]		
		Farea=np.unique(p1[:,1])
		proh=prov=0.0
		for fa in Farea:
			p2=p1[np.where(p1[:,1]==fa)]
			Pheat=p2[:,3].astype(float)
			Pvis=p2[:,4].astype(float)
			if Pheat.sum()/len(Pheat)<0.66:
				#detail_leak(area,scen,target,p):
				#Scen_imp.append([area[:-1],wd,ws,LP,l[:-3],ma,fa,'h'])
				g22=detail_leak(area[:-1],scen,'loe_rad',Pscen)
				g22=g22[:-1]
				g22.append(fa)
				g22.append(Pscen)
				Scen_imp.append(g22)
				proh=Pscen
			if Pvis.sum()/len(Pvis)<0.66:
				#Scen_imp.append([scen,area[:-1],wd,ws,LP,l[:-3],ma,fa,'s'])
				g22=detail_leak(area[:-1],scen,'loe_sight',Pscen)
				g22=g22[:-1]
				g22.append(fa)
				g22.append(Pscen)
				Scen_imp.append(g22)
				prov=Pscen
		A.append([proh,prov])
	A=np.array(A)	
	return A,Pscen,Scen_imp
def ign_w(Ip,A):
	W=np.zeros(A.shape)
	W[:,0]=A[:,0]
	m=A[:,1:].sum(axis=1)
	for i in range(A.shape[0]):
		#da=A[i,1:]*Ip
		#W[i,1:]=da/da.sum()*m[i]
		W[i,1:]=A[i,1:]*Ip
	#print 'Sum W: ', np.sum(W[:,1:]) #Added by obf
	return W	
def probscen(scen,Ap,Wp1,Ld,Ip):
	LP=int(scen.split('_')[0])
	F=True
	wd=str(scen.split('_')[2])
	ws=float(scen.split('_')[3])
	jw=np.where(np.array(['NORTH','SOUTH','EAST','WEST'])==wd)[0][0]+1
	Wp=ign_w(Ip,Wp1)
	iw=np.where(Wp[:,0]==ws)[0][0]
	i=0
	while F:
		if (Ld*i+1)<= LP and LP <=(Ld*i+Ld):
			lpi=i
			F=False
		i+=1	
	P_ap=Ap[lpi]
	P_ld=1/Ld
	P_w=Wp[iw,jw]
#	print P_ap,P_ld,P_w,P_ign,P_ap*P_ld*P_w*P_ign
	return P_ap*P_ld*P_w
def get_data(a,l,D,W):
	S1=False
	Scen=[]
	LeakD=6.
	Ip=np.array([])
 	for d in D:
		dd=d.split()
		if len(dd)>=2:
			if dd[0]=='Area:':
					if dd[1]==a:
						S1=True
					else:
						S1=False
			elif dd[0]=='LeakR:' and S1:
					if dd[1]==l:
						S1=True
					else:
						S1=False
			elif dd[0]=='Leak_dir:' and S1:
				LeakD=float(dd[1])
			elif dd[0]=='IgnP:' and S1:	
				Ip=np.array(dd[1:],dtype=float)
			elif dd[0]=='LeakD:' and S1:
				ddd=np.array(dd[1:],dtype=float)
				AreaP=ddd
			elif dd[0]=='Winds:' and S1:
				ddd=np.array(dd[1:],dtype=float)
				Wind=wind(W,ddd,len(ddd))
			elif S1:
				Scen.append(dd)
	if Ip.shape[0]==0:
		Ip=np.ones(4)
	Scen=np.array(Scen)
	Wind=np.array(Wind)
	D=[AreaP,Wind,LeakD,Scen,Ip]
	return D
def fz_wegit(test,area,Marea,B,fz_data,Bfz,extra,path):
	fz=[]
	F=False
	E=False	
	BT,Bak=csvtoarray2(path,'bakvolum_'+area)	
	RT,Rat=csvtoarray2(path,'rater_'+area)
	if BT and RT:
		print 'Transient leak is included for area '+area
		rater=np.unique(Rat[:,2])
		seg=len(np.unique(Rat[:,1]))
	for d in fz_data:
		f=d.split(',')
		if len(f)<=2:
			if f[0].rstrip()==area:
				F=True
				E=True
			else:
				F=False
		if len(f)>3:
			if F:
				fz.append(f)
	if E:
		fz=np.array(fz,dtype=float)
		cat0=fz[:,np.where(fz[0]<=1.0)[0]]
		cat1=fz[:,np.where(fz[0]>1.0)[0]]
		cat1=cat1[:,np.where(cat1[0]<=10.0)[0]]
		cat2=fz[:,np.where(fz[0]>10.0)[0]]
		cat2=cat2[:,np.where(cat1[0]<=30.0)[0]]
		cat3=fz[:,np.where(fz[0]>30.0)[0]]
		cat=[cat0,cat1,cat2,cat3]
		leakcat=['Small','Medium','Major','Large']
		for i in range((B.shape[1]-1)/2):
			x=np.append(0,B[:,0])
			x=np.append(x,10000)
			yheat=np.append(0,B[:,1+2*i])
			yheat=np.append(yheat,1.0)
			ysight=np.append(0,B[:,2+2*i])
			ysight=np.append(ysight,1.0)
			f_heat=intp.interp1d(x,yheat,kind='linear')
			f_sight=intp.interp1d(x,ysight,kind='linear')
			C=[]
			k=0
			for c in cat:
				Pimp_g_heat=Pimp_g_sight=Pimp_s_heat=Pimp_s_sight=0.0
				for j in range(c.shape[1]):
					x0=c[0,j]
					ESC=False
					if extra>0:
						x0+=extra
						ESC=True
					if BT and RT:
						x0=trans_leak(x0,Bak,Rat,rater,seg)
					fz_g=c[1,j]		
					fz_g_tot=c[1].sum()
					fz_s=c[2,j]
					fz_s_tot=c[2].sum()
					Pimp_g_heat+=fz_g*f_heat(x0)/fz_g_tot
					Pimp_g_sight+=fz_g*f_sight(x0)/fz_g_tot
					Pimp_s_heat+=fz_s*f_heat(x0)/fz_s_tot
					Pimp_s_sight+=fz_s*f_sight(x0)/fz_s_tot
				#Bfz.append([area,,'gas','loe_rad',Marea[i],leakcat[k],Pimp_g_heat,Pimp_g_sight,Pimp_s_heat,Pimp_s_sight])
				Bfz.append([area,ESC,'gas','loe_rad',Marea[i],leakcat[k],Pimp_g_heat])
				Bfz.append([area,ESC,'liq','loe_rad',Marea[i],leakcat[k],Pimp_s_heat])
				Bfz.append([area,ESC,'gas','loe_sight',Marea[i],leakcat[k],Pimp_g_sight])
				Bfz.append([area,ESC,'liq','loe_sight',Marea[i],leakcat[k],Pimp_s_sight])
				k+=1
	return Bfz			
def trans_leak(x,Bak,Rat,rater,seg):
	A=np.where(rater>=x)[0]
	length_r=len(rater)
	x_ny=0.0
	if len(A)==0:
		ri=length_r-1
	else:
		ri=A[0]
	for s in range(seg):
		x_ny+=Bak[s,ri+1]*np.average(Rat[ri+s*length_r,2:12])
	return x_ny
######################################### Escape time ################################################
def cmat(A,Dmat,Smin):
	SminA=np.where(A[0]==Smin)
	for s in SminA[0]:
		r=Dmat[s]+A[0][s]
		for e in range(len(r)):
			if r[e]<A[0][e]:
				A[0][e]=r[e]	
				A[1][e]=s	
	return A
def finddist1(Dmat,A,B):
	Smin_old=0
	Smin=A[0][np.where(A[0]>Smin_old)].min()
	Tmin_old=0
	Tmin=B[0][np.where(B[0]>Tmin_old)].min()
	i=0
	while (A[0]+B[0]).min()>(Smin+Tmin):
		if Smin <= Tmin:
			A=cmat(A,Dmat,Smin)
			Smin_old=Smin
			Smin=A[0][np.where(A[0]>Smin_old)].min()
		else:
			B=cmat(B,Dmat,Tmin)
			Tmin_old=Tmin
			Tmin=B[0][np.where(B[0]>Tmin_old)].min()
		i+=1
	return (A[0]+B[0]).min()
def svensk(Dmat,NodeA,E,C):
	num_nodes=len(NodeA)
	NodeB=[]
	A=np.zeros((2,num_nodes))
	B=np.zeros((2,num_nodes))
	for i in range(num_nodes):
		l=NodeA[i]
		p=[]
		for c in C[i]:
			d=np.inf
			if c[0][0]==i:
				num=c[0][1]
			else:
				num=c[0][0]
			for e in E:
				A[0]=Dmat[num]
				A[1]=np.ones((1,num_nodes))*num
				B[0]=Dmat[e]
				B[1]=np.ones((1,num_nodes))*e
				dist=finddist1(Dmat,A,B)
				if dist<d:
					d=dist
			v=(num,'Escape_'+str(c[0][0])+'_'+str(c[0][1]),d,c[1][0],c[1][1],c[1][2])	
			p.append(v)
		dtype=[('p',int),('n','S20'),('l',float),('x',float),('y',float),('z',float)]
		p=np.array(p,dtype=dtype)
		p=np.sort(p,order='l')
		NodeB.append([p,l[1:]])
	return NodeB
def finddist(A,E):
	length=100000
	for e in E:
		lnew=np.sqrt((A[0]-e[0])**2+(A[1]-e[1])**2+(A[2]-e[2])**2)
		if lnew<length:
			length=lnew
	return length
def dist_matrix(NodeA,ConA):
	A=np.ones((len(NodeA),len(NodeA)))*np.inf
	C=[]
	for l in NodeA:
		a=[l[0]]
		l0=l[1:]
		B=ConA[np.where(ConA==int(l[0]))[0]]
		c=[]
		for b in B:
			l2=NodeA[np.where(NodeA[:,0]==b[0])[0]][0][1:]
			l3=NodeA[np.where(NodeA[:,0]==b[1])[0]][0][1:]
			if l[0]==b[0]:
				dl2=(l3-l2)
			else:
				dl2=(l2-l3)
			c.append([b,dl2])	
			if b[0] not in a:
				a.append(b[0])
	 	for obj in a: 
			l1=NodeA[np.where(NodeA[:,0]==obj)[0]][0][1:]
			dl=abs(l0-l1).sum()
			A[l[0],obj]=dl	
			A[obj,l[0]]=dl
		C.append(c)
	return A,C
def endnode1(NodeA,ConA,end):
	E=[]
	En=[]	
	A=ConA[np.where(ConA==end)[0]]
	for a in A:
		if a[0]!=end:
			E.append(NodeA[np.where(NodeA==a[0])[0]][0][1:])
			En.append(a[0])
		elif a[1]!=end:
			E.append(NodeA[np.where(NodeA==a[1])[0]][0][1:])
			En.append(a[1])
	return E,En
def norman(NodeA,ConA,end):
	B=[]
	i=0
	E,En=endnode1(NodeA,ConA,end)
	for l in NodeA:
#		p=[int(l[0])]	
		p=[]	
		g=[]	
		A=ConA[np.where(ConA==int(l[0]))[0]]
		for a in A:
			s0=NodeA[np.where(NodeA[:,0]==a[0])[0]][0][1:]
			s1=NodeA[np.where(NodeA[:,0]==a[1])[0]][0][1:]
			if a[0]==l[0]:
				s=(s1-s0)
			else:
				s=(s0-s1)
			if a[0]!=int(l[0]) and not a[0] in g and a[0]!=end:
				lnew=finddist(s0,E)
				g.append(a[0])
				c=(a[0],'Escape_'+str(a[0])+'_'+str(a[1]),lnew,s[0],s[1],s[2])
			elif a[1]!=int(l[0]) and not a[1] in g and a[1]!=end:
				lnew=finddist(s1,E)
				g.append(a[1])
				c=(a[1],'Escape_'+str(a[0])+'_'+str(a[1]),lnew,s[0],s[1],s[2])
			p.append(c)
		dtype=[('p',int),('n','S20'),('l',float),('x',float),('y',float),('z',float)]
		p=np.array(p,dtype=dtype)
		p=np.sort(p,order='l')
		B.append([p,l[1:]])
		i+=1
	return B,En
def timef1(x,y,z):
	xspeed=1.3
	yspeed=1.3
	if z<0:
		zspeed=0.38
	else:	
		zspeed=0.3
	dt=abs(x)/xspeed+abs(y)/yspeed+abs(z)/zspeed
	return dt	
def tout(A,p,t,dt):
	if p in A:
		t+=dt
	else:
		t=0.0
	return t
def walkway(nt,NodeA,SconA,end,loe,mr,mv,W,ename,F,time,Outside,time_out):
	S=NodeA[nt]
	P=S[0]
	for p in P:
		mrv= mr[np.where(ename==p[1])]
		if len(mrv)==0:
			mrv=0
		else:	
			mrv=mrv[0]
		mvv=mv[np.where(ename==p[1])]
		if len(mvv)==0:
			mvv=np.inf
		else:
			mvv=(mvv)[0]
		if not F:
			d1=np.array([p[0],nt])
			d2=np.array([nt,p[0]])
			#print d1
			#print W
			if (np.all(SconA==d1,axis=1).any() or np.all(SconA==d2,axis=1).any()) and p[0] not in W:
				dt=timef1(p[3],p[4],p[5])
				time+=dt
				time_out=tout(Outside,nt,time_out,dt)
				W.append(p[0])
				if p[0] in end:
					F=True
				else:
					time,time_out,W,F=walkway(p[0],NodeA,SconA,end,loe,mr,mv,W,ename,F,time,Outside,time_out)
				if not F:
					time+=dt
					time_out=tout(Outside,nt,time_out,dt)
			elif loe[0][0]*loe[0][1]>mrv*loe[0][0] and loe[1][0]*loe[1][1]>mvv*loe[1][0] and p[0] not in W:	 
				dt=timef1(p[3],p[4],p[5])
				time+=dt
				time_out=tout(Outside,nt,time_out,dt)
				W.append(p[0])
				if p[0] in end:
					F=True
				else:
					time,time_out,W,F=walkway(p[0],NodeA,SconA,end,loe,mr,mv,W,ename,F,time,Outside,time_out)
				if not F:
					time+=dt
					time_out=tout(Outside,nt,time_out,dt)
#			else:
#				if loe[0][0]*loe[0][1]>mrv*loe[0][0]:	 
#					print '################'
#					print 'heat',loe[0][0]*loe[0][1],'>',mrv*loe[0][0]
					#print 'sight',loe[1][0]*loe[1][1],'>',mvv*loe[1][0]
				
	return time,time_out,W,F
def etcalc(a,l,NodeA,SconA,end,loe,Bstr,nation,STOCK,C,Dmat,Node,B,Outside):
	U=[]
	d=os.path.join(os.getcwd(),a)
	d=os.path.join(d,l)
	d=os.path.join(d,'EXPLOR_R3D')
	MaxR=csvtoarray_str(d,'max_rad_in_escape_routes_.csv')	
	MinV=csvtoarray_str(d,'min_vis_in_escape_routes_.csv')	
	ename=np.array(MaxR[0][1:])
	length_NodeA=len(NodeA)
	for r in range(len(MaxR)-1):
		mr=np.array(MaxR[r+1][1:])
		scen=MaxR[r+1][0]
		mr=mr.astype(float)
		mv=np.array(MinV[r+1][1:])
		mv=mv.astype(float)
		if STOCK:
			Umat=np.copy(Dmat)
			for sto in range(len(ename)):
				if mr[sto]*loe[0][0]>loe[0][0]*loe[0][1] or mv[sto]*loe[1][0]>loe[1][0]*loe[1][1]:
					num1=int(ename[sto].split('_')[1])	 
					num2=int(ename[sto].split('_')[2])
					Umat[num1][num2]=np.inf
					Umat[num2][num1]=np.inf
			NodeA=svensk(Umat,Node,end,C)
		for i in range(length_NodeA-1):
			W=[i]
			F=False
			time=0.0
			time_out=0.0
			cord=NodeA[i][-1]
			if i not in end:
				time,time_out,W,F=walkway(i,NodeA,SconA,end,loe,mr,mv,W,ename,F,time,Outside,time_out)
				time_out=time-time_out
			if  F:	
				W=np.array(W)
				f=os.path.splitext(os.path.split(scen)[1])[0]
				b=(scen,f.split('_')[1][:-2],f.split('_')[3],f.split('_')[2],f.split('_')[0],time,W[0],cord[0],cord[1],cord[2],nation,time_out)
				B.append(b)
				step=''
				for w in W:
					step+=str(w)+' '
				Bstr+=scen+','+str(f.split('_')[1])+','+str(f.split('_')[3])+','+str(f.split('_')[2])+','+str(f.split('_')[0])+','+str(time)+','+str(W[0])+','+str(cord[0])+','+str(cord[1])+','+str(cord[2])+','+str(nation)+','+str(time_out)+','+step+'\n'
			U.append([scen,W])
	return B,U,Bstr
def escapetime(LEAKC,AREA,graph,vol):
	NodeA=csvtoarray(graph,'nodecords.csv')
	Node=np.copy(NodeA)	
	ConA=csvtoarray(graph,'connectivity.csv')	
	SconA=csvtoarray(graph,'safe_connections.csv')	
	end=int(csvtoarray(graph,'endnode'))
	loe=csvtoarray_str(graph,'loe')
	Outside=[]
	if len(vol)>1:
		for a in NodeA:
			if len(vol)==6:
				if not testp(a,vol):
					Outside.append(a[0])	
			if len(vol)==7:
				if not lambdap(a,vol):
					Outside.append(a[0])	
	a=[]
	for l in loe:
		a.append([sign(l.split()[0]),float(l.split()[1])])
	loe=list(a)	
	ConA=ConA.astype(int)
	SconA=SconA.astype(int)
	Dmat,C=dist_matrix(NodeA,ConA)
	string=''
	NodeA,end=norman(NodeA,ConA,end)
	NodeB=svensk(Dmat,Node,end,C)
	for a in AREA:
		Bstr='Filename,Leak rate [kg/s],Wind speed [m/s],Wind direction,Scenario,Time [s],Starting point [-],X [m],Y [m],Z [m],Person Type,Time_out [s],Steps\n'
		B=[]
		for l in LEAKC:
			B,wayA,Bstr=etcalc(a,l,NodeA,SconA,end,loe,Bstr,'N',False,C,[],Node,B,Outside)
			B,wayB,Bstr=etcalc(a,l,NodeB,SconA,end,loe,Bstr,'S',False,C,[],Node,B,Outside)
			B,wayC,Bstr=etcalc(a,l,NodeB,SconA,end,loe,Bstr,'ST',True,C,Dmat,Node,B,Outside)
		dtype=[('scen','S500'),('leakr',float),('wspeed',float),('wdir','S20'),('sc',int),('time',float),('spoint',int),('x',float),('y',float),('z',float),('person','S10'),('t_outside_v',float)]
		B=np.array(B,dtype=dtype)
		db=shelve.open('shelve_'+a[:-1])
		db['res1']=[B]
		db.close()
		csvfil('Time_'+a[:-1]+'.csv',Bstr)
def cireldiagram(file):
	A=np.genfromtxt(file,dtype=str,delimiter=',')
	L=A[0]
	A=A[1:]
	A=addtarget(A)
	Area=np.unique(A[:,0])
	Type=np.unique(A[:,1])
	Target=np.unique(A[:,-1])
	for a in Area:
		B=A[np.where(A==a)[0]]
		for t in Type:
			B1=B[np.where(B==t)[0]]
			dS=np.unique(B[:,2])
			for ta in Target:
				B2=B1[np.where(B1==ta)[0]]
				
				dS2=np.unique(B2[:,-3])
				if dS2.shape[0]>1:
					L=np.unique(B2[:,4])
					for l in L:
						B3=B2[np.where(B2[:,4]==l)[0]]
						P=cmatrixp(B3,dS2)
						plotCirle(dS2,P,a+t+ta+l+'.png')
def plotCirle(sT,A,name):
	B=np.zeros((A.shape))
	B[np.where(A>0)]=1
	fig=plt.figure()
	ax=fig.add_subplot(1,1,1)
	T=A.sum(axis=0)
	num_t=T.shape[0]-1
	if num_t < 2:
		unm_i=4
	else:
		unm_i=num_t+3
	cmap = get_cmap(unm_i)
	R=(T/(np.pi))**(1./2.)
	ix=np.argsort(R)
	circ=plt.Circle((0,0),R[ix[-1]],facecolor=cmap(num_t+1),alpha=0.5,label=sT[ix[-1]])
	ax.add_patch(circ)
	max_r=R[ix[-1]]
	#dx=[-100,-90]
	#ax.plot(dx,dx,color=cmap(num_t+1),label=sT[ix[-1]])
	ax.axis([-2*max_r,2*max_r,-2*max_r, 2*max_r])
	c=np.arange(num_t)*2*np.pi/(num_t)
	for i in range(num_t):
		dB=B[:,ix[-1]]+B[:,ix[i]]
		dA=A[np.where(dB==2)[0]]
		X=dA[:,ix[-1]].sum()
		if R[ix[i]]>0:
			x,y=intersection(max_r,R[ix[i]],X,c[i]) 
			circ=plt.Circle((x,y),R[ix[i]],facecolor=cmap(i),alpha=0.5,label=sT[ix[i]])
			ax.add_patch(circ)
	ax.legend()
	plt.savefig(name)
def intersection(R,r,X,angle):
	a=np.pi*r**2.
	if X==0:
		l=R+r
	elif round(X/a,3)==1.000:
		l=R-r
	elif X/a>1 or X<0:
		print 'X can not be less then 0 or larger then 1 ',X/a
	else:	
		d=np.linspace(R-r,r+R,10000)
		d=d[1:-1]
		d1=(d**2-r**2+R**2)/(2*d)
		d2=(d**2+r**2-R**2)/(2*d)
		A1=R**2.*np.arccos(d1/R)-d1*(R**2.-d1**2.)**(1./2.)
		A2=r**2.*np.arccos(d2/r)-d2*(r**2.-d2**2.)**(1./2.)
		A=A1+A2
		l=d[np.where(A>X)[0][-1]]
	x=l*np.cos(angle)
	y=l*np.sin(angle)
	return x,y
def cmatrixp(B,dS):
	Scen=np.unique(B[:,2])	
	P=np.zeros((Scen.shape[0],dS.shape[0]))
	for i in range(Scen.shape[0]):
		s=Scen[i]
		dB=B[np.where(B==s)[0]]
		for db in dB:
			j=np.where(dS==db[-3])[0][0]
			P[i,j]=float(db[-2])
	return P
def get_cmap(N):
	'''Returns a function that maps each index in 0, 1, ... N-1 to a distinct
	 RGB color.'''
	color_norm  = colors.Normalize(vmin=0, vmax=N-1)
	scalar_map = cmx.ScalarMappable(norm=color_norm, cmap='hsv') 
	def map_index_to_rgb_color(index):
		return scalar_map.to_rgba(index)
	return map_index_to_rgb_color
def addtarget(A):
	B=[]
	for a in A:
		B.append(np.append(a,a[-2][:-1]))
	B=np.array(B)
	return B
######################################### standard functions ################################################
def lambdap(a,vol):
	F=True
	for i in range(2):
		if F:
			F=p_in_v(float(v[i]),float(v[i+3]),float(a[1+i]),F)	
	if F:
		lambdaf(x,y,f)
	return F
def lambdaf(x,y,f):
	eq=eval(f)
def testp(a,v):
	F=True
	for i in range(3):
		if F:
			F=p_in_v(float(v[i]),float(v[i+3]),float(a[1+i]),F)	
	return F
def p_in_v(xmin,xmax,p,F):
	F=False
	if xmin<=p and p<=xmax:
		F=True
	return F
def wtextf(filnamn,text):
	fil=open(filnamn,'w')
	fil.write(text)
	fil.close()
def findfiles(path,test):
	path=os.path.abspath(path)
	result=[]
	for dir, dirs, files in os.walk(path):
		for word in files:
			if re.match(test,word):
				print dir,word
				result.append(os.path.join(dir,word))
	return result
def findfile(path,test):
	result = []
	absf = []
	for files in os.listdir(path):
		f=os.path.join(path,files)
		if os.path.isfile(f):
			if re.match(test,f):
				result.append(files)
				absf.append(f)
	return result,absf
def isnumeric(value):
        return str(value).replace(".", "").replace("-", "").isdigit()
def sign(s):
	sign=0
	if s=='>':
		sign=1.0
	elif s=='<':
		sign=-1.0
	else:
		print 'Error sign'
	return sign

def testftostr(d,f):	
	fil,T=isfil(d,f)
	if T:
		fil=open(fil,'r')
		dat=fil.readlines()
		fil.close()	
#		A= np.genfromtxt(dat, dtype=str, delimiter=',')	
	return dat
def csvtoarray_str(d,f):
	A=[]
	fil,T=isfil(d,f)
	if T:
		A= np.genfromtxt(fil, dtype=str, delimiter=',')	
	return A
def reshape(A):
	if  len(A.shape)==1:
		A=A.reshape(1,len(A))
	return A
def csvtoarray(d,f):
	A=[]
	fil,T=isfil(d,f)
	if T:
		A= np.genfromtxt(fil, dtype=float, delimiter=',')	
	return A
def csvtoarray2(d,f):
	A=[]
	fil,T=isfil2(d,f)
	if T:
		A= np.genfromtxt(fil, dtype=float, delimiter=',')	
	return T,A
def is_number(s):
	try:
		float(s)
		return True
	except ValuError:
		return False
def make_dir(f):
	d = os.path.dirname(f)
	if not os.path.exists(d):
        	os.makedirs(d)
def isfil(d,f):
	F=True
	f=os.path.join(os.path.abspath(d),f)
	if not os.path.exists(f):
		print 'Error no such file: '+f	
		F=False
	return f,F
def isfil2(d,f):
	F=True
	f=os.path.join(os.path.abspath(d),f)
	if not os.path.exists(f):
		F=False
	return f,F
def array(name,A):
	i=0
	for a in A:
		if str(a[0])==name:
			break	
		else:
			i+=1
	return i
def csvfil(name,string):
	Array=[]
	A=string.split('\n')
	for a in A:
		B=a.split(',')
		C=[]
		if len(B)>1:
			for b in B:
				C.append(b)
			Array.append(C)	
	with open(name, 'wb') as fd:
		writer = csv.writer(fd)
		for l in Array:
			writer.writerow(l)
def find_nearest(array,value):
	idx = (np.abs(array-value)).argmin()
	return idx
#############################################################################
# Script starts from here
#############################################################################
if len(sys.argv) < 2:
	print 'No action specified. Print --help for more details'
	sys.exit()
if sys.argv[1].startswith('--'):
	option = sys.argv[1][2:]
	# fetch sys.argv[1] but without the first two characters
	if option == 'version':
		print 'Version 2.2'
	elif option == 'f_help':
		print '''\
\033[1mFile syntax\033[0;0m
This section provides information of syntax and input of the different files. Each file is also represented by a example. All files needs to be saved in EINPUT directory.   

\033[1mScenario input file \033[0;0m
Provide input in order to created scenarios. The inputs are Maximum time, maximum alowed value for courant number, ref hight for sea level and amibient temperature. 
scen_input:
Max_time  500
COUMAX  10
Sea_level  473
Amb_temp  273


\033[1mNode file \033[0;0m
The file needs to be saved in the EINPUT directory.
The file needs to be saved in the same folder as the other files.
Node_file:
0,40.5,285.0,501.7
1,40.5,316.0,501.1
2,40.5,314.5,501.1
3,60.0,314.5,501.1
4,60.0,316.0,501.1
5,65.0,314.5,501.1
6,87.0,285.0,501.7
7,87.0,314.5,501.1
stop_name
8,90.0,294.0,501.1
9,90.0,299.0,501.1
10,92.0,285.0,501.7
11,92.0,287.0,501.7
.
.
\033[1m leakr_probability file\033[0;0m
This file together wit option b makes it possible to set a impairment probability for given 
leak rate. The syntax of the file is as follows; the first line is the line for the heading names 
of each column. Column 0 is assigned for the leak rate, column 1+2xi is assigned for the 
probability impairment for heat in area i  and 2+2xi is assigned for the probability impairment 
for sight in area i. The file has to be saved in the EINPUT directory.

leakr_probability:
leakrate,h_a1,v_a1,h_a2,v_a2
5,0.5,0.5,0.3,0.3
600,0.9,0.9,0.2,0.2


\033[1mCon file \033[0;0m
The file needs to be saved in the EINPUT directory.
The file needs to be saved in the same folder as the other files.
con_file:
0,6,s
6,10
10,11
10,18
11,12
12,13
9,13
8,9
13,14,e
.
.

\033[1mStartNodesAndNames \033[0;0m
StartNodesAndNames consists of startpoints in the escape route grid. the name of the startpoint is followed by the number of the startpoint find in nodecords.csv. The name of the start point has a 
underlying syntax where areas with same string except for the the last digit(s) after the underscore belongs to de same deck level and next last charter before the underscore bleongs to the same module. 
In the syntax example below P100_1 and P100_2 belongs to the same deck level and P100 and P101 belongs to the same module. 

startNodesAndNames.csv:
area_name,node
P100_1,3
P100_2,4
P101_1,22
P101_2,66
P200_1,3
P200_2,4
.
.

\033[1mEndnode \033[0;0m
The file needs to be saved in the same folder as the other files.
endnode:
14

\033[1mWeather \033[0;0m
The file needs to be saved in the same folder as the other files.
weather:
w1 N1 S1 E1 W1
w2 N2 S2 E2 W2
. 
.
wn Nn Sn En Wn

\033[1mLeakfz \033[0;0m
The file needs to be saved in the same folder as the other files.
leakfz:
AREA1  
q11, q12, ... q1m
fzg11, fzg12, ...,fzg1m
fzlq11, fzlq12, ...,fzlq1m
.
.
AREAn  
qn1, qn2, ... qnm
fzgn1, fzgn2, ...,fzgnm
fzlqn1, fzlqn2, ...,fzlqnm

\033[1mData \033[0;0m
The data file specifies uniqe information about each area such as; leak rate (LeakR:), wind speeds (Winds:), probability dist. 
between diffrint leak points (LeakD:). It is also possible to specify symetri between diffrent scenrios which can be a good ide if not all simulated scenarios are in place. The syntax for the symetri is:  
the scenario that has not been simulated in the first colum and the simulated scenario in the sceond colum. In addition it is also possible as an extra option to specify the number of leak direction (Leak_dir:)
if it diffes from 6 which is default. Please se example and syntax for all file below. The file needs to be saved in the same folder as the other files.

syntax data file:
Area: P250
LeakR: 10kg
Winds: 5 12
LeakD: 0.2 0.4 0.3 0.1
13_10kg_NORTH_12 2_10kg_NORTH_12
17_10kg_NORTH_5 1_10kg_NORTH_12
25_10kg_SOUTH_12 1_10kg_NORTH_12
Area: P250
LeakR: 25kg
Winds: 5 12
Leak_dir: 5
LeakD: 0.2 0.4 0.3 0.1
13_10kg_NORTH_12 1_10kg_NORTH_5
17_10kg_NORTH_5 1_10kg_NORTH_5
.
.
.

\033[1mLoe \033[0;0m
LOE specifies the limitvalues for heat radtion and sight. The frist line for heat and the second line for sight. The name has to be 'loe' and stored under EINPUT-directory.
loe:
> 6300
< 4
\033[1mPll \033[0;0m
Pll consists of pre defined volumes and names. The name of the volume has a underlying syntax where areas with same string except for the the last digit(s) after the underscore belongs to de same module. 
In the syntax example below P100_1 and P100_2 belongs to the same module.  The file needs to be saved in the same folder as the other files. Default name pll. 
pll:
P100_1,113,285,501.25,138,313,506.25
P250_1,113,285,508.25,138,313,516.25
P300_1,123,285,519.25,138,313,527.25
P400_1,123,285,529.25,138,313,535.25

\033[1mSpecial \033[0;0m
Special consists of pre defined volumes and names. The name of the volume has a underlying syntax where areas with same string except for the the last digit(s) after the underscore belongs to de same module. 
In the syntax example below P100_1 and P100_2 belongs to the same module.  The file needs to be saved in the same folder as the other files. Default name special. 
special:
P100_1,113,290,501.25,133,308,506.25
P100_2,113,290,508.25,138,308,516.25
P300_1,123,290,519.25,133,308,527.25
P400_1,123,290,529.25,133,308,535.2

\033[1mVolume \033[0;0m
Volume consists of pre defined volumes and names. The name of the volume has a underlying syntax where areas with same string except for the the last digit(s) after the underscore belongs to de same module. 
In the syntax example below P100_1 and P100_2 belongs to the same module.  The file needs to be saved in the same folder as the other files. Default name volume. 
volume:
P100_1,112,285,500.25,139,313,507.25
P250_1,112,285,507.25,139,313,517.25
P300_1,121,285,518.25,139,313,529.25

\033[1mTest configuration of escape route network\033[0;0m
 This text file will be used in order to evaluate different configurations of new safe conections and new end points on exsisting network.Each line is test of a unqie configuration. those parts that are consider as safe needs to be folloowed by either s,e or x.
The name of the input file needs to.    
test_conf_of_escape_route:

'''
	elif option == 'help':
		print '''\
\033[1mDESCRIPTION \033[0;0m
This program provide help to run probablistic fire analysis according to explore and handels the entire chain form setup to post-processing. The folowing optinons are included:
   - create fire scenarios out of source scenario. gridgen2.0.py will help you to create advanced grids. 
   - create the directory stucture. 
   - create the Node_file con_file etc. Those files needs to be in place in order to run explore.
   - run explore escape, see optinon a,c,g. 
   - calculate the impact for each categorie base on weather stat. and frequency (frequency weighted), see option -w. 

 
REMARK!!! The program has parameters valid only for GK.
Usage: python setup_fire.py [OPTION]

\033[1mOPTIONS\033[0;0m
Options include: 
  -d	    : Create scenarios from one or several source scenarios and wind speeds. The name of the files in the source scenario needs to be \033[1mscenario\033[0;0m. The release cell in scenario.fsc has to bee 
 	      "Release positive Y-dir" and the name of the release cell has to be Jet_cell.

  -p	    : if option p is added to (d) the secenrio will be pool fire.  

  -sub      : makes it possibble to use transient leak cells. 

  -o 	    : Creats a kfx geometry file out of Node_file.csn and/or con_file.csv. In order to get an id number for a new point in Node_file.csn typ in 'x' followed by the coordinate, e.g. x,0,0,0.
	      Add 's' to the end of a line in the con_file.csv file for safe conection and 'e' for endnode. 

  -f 	    : This otion will produce the outputfiels used by the explor script. 

  -a 	    : This otion toghter with option (pa) (c) and (g) will run explore. (a) followed by the area(s) 

  -c 	    : This otion toghter with option (pa) (a) and (g) will run explore. (c) followed by the leakcategories 

  -g 	    : This otion toghter with option (pa) (a) and (c) will run explore. (a) The program needs seven files in order to run; five files from option (o) nodecords.csv, connectivity.csv, safe_connections.csv,
	      newGrid.dat, escape.kfx and two manual created files; startNodesAndNames.csv endnode. Example of syntax for startNodesAndNames.csv and endnode can be found below.

  -pa 	    : This otion toghter with option (a), (c) and (g) exctrates effect on LOE, PLL, spreading or volume. For LOE; a file specifing the limits for heat and sight has to be sotred in EINPUT-dir,for PLL; 'pll' followed by bigger or smaller then ( '>' or '<')  and critical value, 
	      for spreading: spe followed by bigger or smaller then ( '>' or '<') and critical value and criteria for volume ration (0.0-1.0), for volume: 'vol' followed by bigger or smaller then ( '>' or '<')  
	      and critical value. Each of the options needs a input file stored in directory for option (g). If not the name of the input file is added the default file will be used. 
	      For more information about the files please see --f_help.  

  -v 	    : Option (pa) and (w) operates on heat radition by default. Adding this option will make it posible to operate on other result files e.g SIGHT, Temp etc. The default name is RA35.  
              The name needs to be followed by the name of the result variable e.g -v sight  (since  scenario_sight_exit.r3d)     

  -w 	    : This otion will include the wind statistic and frequency weighted the probability. The name of the weather file has to be weather and the leakfrequency leakf.csv and data input file data. 
	      For more information about the data file please typ in --f_help.  

  -sce 	    : creates kfx geometry file with the impairment on the escape route. In addition, for those starting points which will get tot the safe area, a csv file (way_out.csv) including the excat 
	      route will be created. the option folowed by: the path to the scenario folder, rad/vis, bigger or smaller then ( '>' or '<'), value. Option (g) needs to be includede too. It is possible to extract the 
	      Togather with option (tm) it is possible to visualize a single persons way to safe area. This options requires the Time_*.csv file in oder to run. The option needs both heat radiation and visibility 
	      level criteria as shown in the examlpe below. The color code from the result file (*both*.kfx) are as following; black unused, green used, red impaired by heat and sight, pink heat, yellow sight.
              The tm option has to b e followed by startiing point and person type (N,S,ST)      

  -tm	    : calulates the time to escape. The option need the result from the loe study in order to run. If tm is followed by 3D interval (and function) the time to get outside the volume will be reported.  

  -e 	    : this option togather with (w) will calculate the consequence from a fire escalation due to specified rate in kg/s.  

  -opt 	    : this option togather with '-w loe' will test different combinations of safe connectinons in order to find the routes that are most critical in LOE.   

  -t 	    : this option togather with (w) will not include fz-weighted probability. 

  -b 	    : this option togather with '-w loe' will be used in order to evlaute different configurations of new safe conections and new end points on exsisting network. Option (b) has to be followed by
	      the name of the scenario input file saved in EINPUT. As an option it is possible to set the probability for impairment for different leak rates by creating a leakr_probability file (p_imp_file). 
	      The name of the file has to be on the second position after (b) and stored under EINPUT . The syntax of the file can be found in f_help.

  -bg	    : Create a kfx geometry file showing the escape network for a given sensitivity. Color code: green = safe, red = unsafe, blue = conection to end point, black = paths excluded in the sensitvity. 

  -cd	    : Create plots showing the probability of impairment between the different deck levles for loe. The size of the circles represent te relativ probability for each deck. The option 
	      followed by the inputfile (Scenprob_name.csv)  

  -s 	    : add name to case which will also be added to all related files. 

  -cr 	    : This option toghter with option (c) and (a) will create the dir structure.

  -tot 	    : Add all Impprob* Leakprob* ScenImp* into IMPPROB LEAKPROB and SCENIMP for a given dir. option followed by dir.  

  -mp 	    : Map imparment on escape network. option follwed by path/, type (rad or vis), sign (< or >) and value.

  --help    : Display this help. 

  --f_help  : Display the setup for diferent files. 

  --version : Print the version.

For more information about the files please typ in --f_help.

\033[1mEXAMPLES\033[0;0m
setup_fire.py -cr -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 
setup_fire.py -d w1 w2 input_scen_1 input_scen_2 -g ../../EINPUT/
setup_fire.py -d w1 w2 input_scen_1 input_scen_2 -p -g ../../EINPUT/
setup_fire.py -d w1 w2 input_scen_1 input_scen_2  -sub -p -g ../../EINPUT/
setup_fire.py -o Node_file.csn con_file.csn 
setup_fire.py -o Node_file.csn con_file.csn -f
setup_fire.py -pa loe -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -pa spe \> value ratio sep_va.txt -s name -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -pa vol \> value -s name -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -pa vol \< value -s name -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/ -v sight
setup_fire.py -pa pll \> value -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -w vol -s name -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -e 100 -w pll -s name -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -w spe -s name -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -w all -s name -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -w loe -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/
setup_fire.py -w loe -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/ -b scenario_input_file
setup_fire.py -w loe -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/ -b scenario_input_file p_imp_file
setup_fire.py -w loe -l AREA1 -g EINPUT/ -b name_of scenario_input_file
setup_fire.py -w loe -l AREA1 -g EINPUT/ -b name_of scenario_input_file leakr_probability
setup_fire.py -w loe -a P250/ -c 50kg/ -g EINPUT/ -opt P30 vis \< 4
setup_fire.py -w loe -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/ -t
setup_fire.py -sce AREA1/LEAKCAT/w1/w_dir/Scenario_n/ rad \> value -g EINPUT/
setup_fire.py -tm -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/ 
setup_fire.py -tm x00 y00 z00 x01 y01 z01, ..., xn0 yn0 zn0 xn1 yn1 zn1  -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/ 
setup_fire.py -tm x0 y0 z0 x1 y1 z1  'lambda x,y: (x**2+y**2+1)**(1./2)' -a AREA1 AREA2 ...  -c LEAKCAT1 LEAKCAT2 ... -g EINPUT/ 
setup_fire.py -sce  AREA1/LEAKCAT/w1/w_dir/Scenario_n/ both \> heat_value \< sight_value -g EINPUT/ -tm # N
setup_fire.py -tot ./  
setup_fire.py -mp  ./ rad \> 6300  
setup_fire.py -cd  file
setup_fire.py -bg  file
'''
	else:
		print 'Unknown option.'
	sys.exit()
elif sys.argv[1].startswith('-'):
	valg= sys.argv[1][1:]
        OPT=[]
	LEAKC=[]
	AREA=[]
	vari='RA35'
	time=[]
	RES=False
	TPOOL=False
	GRAPH=False
	WEATHER=False
	string=''
	global kfxt
	global ESCAL
	global OPTI
	global SCE
	global TIME
	global SUBSEA
	OPTI=False
	TIME=False
	SCE=False
	SUBSEA=False
	ESCAL=False
	BTEST=False
	kfxt='/usr/local/apps/kfx/Linux_i686/bin/kfxtransform '
	if valg == 'd':
		for n in sys.argv[1:]:
			if str(n)=='-sub':
				SUBSEA=True	
			if str(n)=='-p':
				TPOOL=True	
			elif str(n)=='-g':
				GRAPH=True	
				RES=False
			elif str(n)=='-d':
				RES=True
				GRAPH=False
			if RES and str(n[0])!='-':
				OPT.append(n)
			elif GRAPH and str(n[0])!='-':
				graph=str(n)
		bashline(OPT,TPOOL,graph)
	if valg == 'o':
		for n in sys.argv[1:]:
			if str(n)!='-o' and str(n)!='-f':
				OPT.append(n)
			elif str(n)=='-f':
				RES=True
		kfxgeo(OPT,RES)
	if valg == 'sce':
		SCE=True
		for n in sys.argv[1:]:
			if str(n)=='-sce':
				GRAPH=False
				TPOOL=True
				TIME=False
			elif str(n)=='-tm':
				TIME=True
				GRAPH=False
				TPOOL=False
			elif str(n)=='-g':
				TIME=False
				GRAPH=True
				TPOOL=False
			if TPOOL and str(n[0])!='-':
				LEAKC.append(str(n))
			elif GRAPH and str(n[0])!='-':
				graph=str(n)
			elif TIME and str(n[0])!='-':
				time.append(n)
                print LEAKC, graph, time
		single_field_outp(LEAKC,graph,time)
	if valg == 'pa' or valg == 'v':
		PARA=[]
		for n in sys.argv[1:]:
			if str(n)=='-c':
				GRAPH=False
				TPOOL=False
				RES=True
				TC=False
				STRING=False
				VAR=False
			elif str(n)=='-a':
				GRAPH=False
				TPOOL=True
				RES=False
				TC=False
				STRING=False
				VAR=False
			elif str(n)=='-g':
				GRAPH=True
				TPOOL=False
				RES=False
				TC=False
				STRING=False
				VAR=False
			elif str(n)=='-pa':
				GRAPH=False
				TPOOL=False
				RES=False
				TC=True
				STRING=False
				VAR=False
			elif str(n)=='-s':
				GRAPH=False
				TPOOL=False
				RES=False
				TC=False
				STRING=True
				VAR=False
			elif str(n)=='-v':
				GRAPH=False
				TPOOL=False
				RES=False
				TC=False
				STRING=False
				VAR=True
			if RES and str(n[0])!='-':
				LEAKC.append(str(n))
			elif GRAPH and str(n[0])!='-':
				graph=str(n)
			elif TPOOL and str(n[0])!='-':
				AREA.append(str(n))
			elif TC and str(n[0])!='-':
				PARA.append(str(n))
			elif STRING and str(n[0])!='-':
				string='_'+str(n)	
			elif VAR and str(n[0])!='-':
				vari=str(n)	
		if str(PARA[0])=='loe':
			explore(AREA,LEAKC,graph,PARA)
		else:
			exploref(AREA,LEAKC,PARA,graph,string,vari)
	if valg == 'w'or valg == 't' or valg == 'e' :
		WT=''
		escal=0
		TT=True
		path=''
		for n in sys.argv[1:]:
			if str(n)=='-w':
				GRAPH=False
				TPOOL=False
				RES=False
				WEATHER=True
				STRING=False
				VAR=False
				VAR1=False
			elif str(n)=='-l':
				GRAPH=False
				TPOOL=False
				RES=False
				WEATHER=False
				STRING=False
				VAR=False
				VAR1=True
			elif str(n)=='-c':
				GRAPH=False
				TPOOL=False
				RES=True
				WEATHER=False
				STRING=False
				VAR=False
				VAR1=False
			elif str(n)=='-a':
				GRAPH=False
				TPOOL=True
				RES=False
				WEATHER=False
				STRING=False
				VAR=False
				VAR1=False
			elif str(n)=='-g':
				GRAPH=True
				TPOOL=False
				RES=False
				WEATHER=False
				STRING=False
				VAR=False
				VAR1=False
			elif str(n)=='-s':
				GRAPH=False
				TPOOL=False
				RES=False
				WEATHER=False
				STRING=True
				VAR=False
				VAR1=False
			elif str(n)=='-v':
				GRAPH=False
				TPOOL=False
				RES=False
				WEATHER=False
				STRING=False
				VAR=True
				VAR1=False
			elif str(n)=='-e':
				GRAPH=False
				TPOOL=False
				RES=False
				WEATHER=False
				STRING=False
				ESCAL=True
				VAR=False
				VAR1=False
			elif str(n)=='-opt':
				OPTI=True
				STRING=True
				GRAPH=False
				TPOOL=False
				RES=False
				WEATHER=False
				VAR=False
				VAR1=False
				string=[]
			elif str(n)=='-b':
				vari=[]
				BTEST=True
				OPTI=False
				STRING=False
				GRAPH=False
				TPOOL=False
				RES=False
				WEATHER=False
				VAR=False
				VAR1=False
			elif str(n)=='-t':
				TT=False	
			if RES and str(n[0])!='-':
				LEAKC.append(str(n))
			elif GRAPH and str(n[0])!='-':
				graph=str(n)
			elif TPOOL and str(n[0])!='-':
				AREA.append(str(n))
			elif WEATHER and str(n[0])!='-':
				WT=str(n)	
			elif STRING and OPTI and str(n[0])!='-':
				string.append(str(n))	
			elif STRING and str(n[0])!='-':
				string='_'+str(n)	
			elif VAR and str(n[0])!='-':
				vari=str(n)
			elif VAR1 and str(n[0])!='-':
				path=str(n)
			elif ESCAL and str(n[0])!='-':
				escal=float(n)
				print 'Escalated fire of '+n+' kg/s is added'
			elif BTEST and str(n[0])!='-':
				vari.append(n)
		if BTEST:
			w_a_q2(AREA,LEAKC,path,graph,vari,escal,string)
		else:
			w_a_q(AREA,LEAKC,graph,WT,TT,string,vari,escal)
	if valg == 'tm':
		vol=[]
		for n in sys.argv[1:]:
			if str(n)=='-c':
				TPOOL=False
				RES=True
				GRAPH=False
			elif str(n)=='-a':
				TPOOL=True
				RES=False
				GRAPH=False
			elif str(n)=='-g':
				GRAPH=True
				TPOOL=False
				RES=False
			if RES and str(n[0])!='-':
				LEAKC.append(str(n))
			elif TPOOL and str(n[0])!='-':
				AREA.append(str(n))
			elif GRAPH and str(n[0])!='-':
				graph=str(n)
			elif str(n[0])!='-':
				vol.append(n)
		escapetime(LEAKC,AREA,graph,vol)
	if valg == 'cr':
		for n in sys.argv[1:]:
			if str(n)=='-c':
				TPOOL=False
				RES=True
			elif str(n)=='-a':
				TPOOL=True
				RES=False
			if RES and str(n[0])!='-':
				LEAKC.append(str(n))
			elif TPOOL and str(n[0])!='-':
				AREA.append(str(n))
		c_folder(AREA,LEAKC)
	if valg == 'tot':
		tot_res(sys.argv[2])
	if valg == 'mp':
		map_imp2kfx(sys.argv[2],sys.argv[3],sys.argv[4],sys.argv[5])
	if valg == 'cd':
		cireldiagram(sys.argv[2])
	if valg == 'bg':
		sens2geo(sys.argv[2])
	sys.exit()
else:
	print "!!!!!!!!!!!!!!!!!!!!!----- We consult -----!!!!!!!!!!!!!!!!!!!!!!!!!!"

